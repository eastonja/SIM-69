* ******************************************************
* ******************************************************
* **                                                  **
* **               SMARTBUG FOR THE                   **
* **                     6809                         **
* **                  v 1.27a-S69                     **
* **               WRITTEN 09/11/2023                 **
* **                BY JEFF EASTON                    **
* **                                                  **
* ******************************************************
* ******************************************************
*  
* >>> CONVERTED FROM THE MUX2 PRINTER MULTIPLEXER VERSION   <<<
* >>> SBV126C.  IE. THE Z-1000 TERMINAL CONCENTRATOR	    <<<
*
* v0.01	02/27/2022	Jeff Easton 	Change autoincrement cmds from 0,x+ to ,x+ for LWTools assembler
* V0.02	02/28/2022	Jeff Easton		Add console routines for 6850 (comment out ones not used!) moved RAMV to $0300, AUXROM $8000
* V0.03	04/17/2022	Jeff Easton		Add defs for VIA1 and P8584.  Added general drivers for i2c read/write and init, Change 6551 to 19.2Baud, 8584 i2c to 8MHz clk
* V0.04 04/22/2022	Jeff Easton		rework RTC and sEEPROM Read routines.  Add sEEPROM Write routine. 
* V0.05	04/26/2022	Jeff Easton		Add drivers for I2C LCD Module
* v0.06 07/16/2023	Jeff Easton		Ported from SB 1.26c-S50.  Added Direct Bus LCD AND Copy to Parallel EEPROM routines
* v0.07	07/17/2023	Jeff EASTON		Changed name of DL command to DS.  Added DI command for Download Intel Hex Files
* V0.08	07/21/2023	Jeff EASTON		Add CL command, RTC display and set routine
* V0.09 08/01/2023	Jeff Easton		Remap all IO from $8000 to $AF00.  Requires GAL change for 64kb RAM chip. Opens space for more ram at $8000, $9000 and most of $A000 
* V0.10	09/08/2023	JEFF EASTON		CHANGED LDS #RAMTOP TO LDS #STACK ON WARMST AND CTRLC ROUTINES, ADD EW AND CP COMMANDS, ADD I2CTXONE ROUTINE, REWRITE ALL OLED ROUTINES
* V0.11	09/12/2023	JEFF EASTON		ADDED BANK SWITCHING FOR EEPROM, ADDED ER, EEPROM READ COMMAND.  VERSION 1.27a RELEASE
*
* THESE ARE THE CONSTANTS THAT THE ROM IS 
* ASSEMBLED WITH.
*
RAM     EQU		$0000		* BASE OF RAM PAGE
RAMTOP  EQU		$00FF		* TOP OF DIRECT PAGE
STACK	EQU		$01FF		* TOP OF SYSTEM STACK
USTACK	EQU		$02FF		* TOP OF USER STACK
RAMV	EQU		$0300		* START OF VAR. STORAGE
ACIA	EQU		$AF00		* DEFAULT SERIAL PORT 6551-1 (base of all IO)
ACIA2	EQU		$AF10		* SECONDARY SERIAL PORT 6551-2
ACIA8	EQU		$AFF0		* ALTERNATE SERIAL PORT 6850 (NOT USED)
VIA1	EQU		$AF20		* VIA #1 BASE ADDRESS 6522-1
VIA2	EQU		$AF30		* VIA #2 BASE ADDRESS 6522-2
P8584	EQU		$AF80		* BASE ADDRESS OF I2C CHIP
LCDB	EQU		$AF90		* BASE OF DIRECT BUS LCD MODULE
EEPROM	EQU		$B000		* BASE OF WRITEABLE EEPROM (28c64) 8k SPACE (BANKABLE WITH 28c256)
AUXROM	EQU		EEPROM		* AUXILIARY ROM START ADDRESS
*
* I2C DEVICES
*
RTCADDR	EQU		$D0			* DS1307 REAL TIME CLOCK ADDRESS (1101 000X)
SEEADDR	EQU		$AE			* 24LC256 SERIAL 32KB EEPROM (1010 111X) IE A2, A1 A0 =HI, (ALL JUMPERS OUT)
SECADDR	EQU		$A0			* 24c32 SERIAL 8KB EEPROM (1010 000X) IE A2, A2, A0 =LO, (ALL PINS GND) OPTIONAL SERIAL EEPROM ON SOME RTC BOARDS
LCDADDR	EQU		$4E			* PCF8574T I2C TO PARALLEL CHIP (0100111X)ON I2C LCD PANEL (HLF PCF8574T, T.I. CLONE) 
OLEADDR	EQU		$78			* SSD1309 ON 2.4" 128X64 DOT MATRIX OLED DISPLAY (0111 100X).  ALTERNATE IS $7A IF DC PIN IS HIGH
*
*
*
* SYSTEM CONSOLE I/O DEFAULT  >>> SY6551 ACIA <<<
*
ACIADR  EQU		ACIA		* ACIA DATA REGISTER
ACIASR  EQU		ACIA+1		* ACIA STATUS REGISTER
ACIACR	EQU		ACIA+2		* ACIA COMMAND REGISTER
ACIATR	EQU		ACIA+3		* ACIA CONTROL REGISTER
*
* SYSTEM CONSOLE I/O ALTERNATE  >>> MC6850 ACIA <<<
*
ACIA8CR	EQU		ACIA8		* 6850 CONTROL AND STATUS REGISTER
ACIA8DR	EQU		ACIA8+1		* 6850 DATA REGISTER
*
* VIA #1	>>> SY6522-1 <<<
*
VIA1ORB	EQU		VIA1		* ORB/IRB PORT B OUTPUT/INPUT
VIA1ORA	EQU		VIA1+1		* ORA/IRA PORT A OUTPUT/INPUT
VIA1DRB	EQU		VIA1+2		* DDRB DATA DIRECTION REGISTER B
VIA1DRA	EQU		VIA1+3		* DDRA DATA DIRECTION REGISTER A
*
* VIA #2	>>> SY6522-2 <<<
*
VIA2ORB	EQU		VIA2		* ORB/IRB PORT B OUTPUT/INPUT
VIA2ORA	EQU		VIA2+1		* ORA/IRA PORT A OUTPUT/INPUT
VIA2DRB	EQU		VIA2+2		* DDRB DATA DIRECTION REGISTER B
VIA2DRA	EQU		VIA2+3		* DDRA DATA DIRECTION REGISTER A
*
* P8584 I2C REGISTERS
*
P8584SX	EQU		P8584+0		* S0/S3
P8584S1	EQU		P8584+1		* S1
*
* LCD MODULE DIRECT BUS REGISTERS
*
LCDBIR	EQU		LCDB+0		* LCD DIRECT BUS INSTRUCTION REGISTER
LCDBDR	EQU		LCDB+1		* LCD DIRECT BUS DATA REGISTER
*
* AUXILIARY ROM TABLE STRUCTURE DEFINITIONS
*
AUXCLD	EQU		AUXROM		* AUX ROM COLD START VECTOR
AUXWRM	EQU		AUXROM+2	* AUX ROM WARM START VECTOR
AUXERR	EQU		AUXROM+4	* AUX ROM ERROR HANDLER VECTOR
AUXFLG	EQU		AUXROM+6	* AUX ROM FLAG FOR AUTO START eg '6809'
AUXTFL	EQU		AUXROM+10	* AUX ROM FLAG FOR JUMP TABLE EXTENSION eg 'ETAB'	
AUXTBL	EQU		AUXROM+14	* AUX ROM JUMP TABLE VECTOR
AUXVER	EQU		AUXROM+16	* AUX ROM VERSION NUMBER eg '1.00'
*
*
*
* SET VECTORS AND TABLE SPACE
*
	ORG	RAMV				* SET TO VECTOR SPACE
*
SW3VEC  RMB     2			* SWI3 INTERRUPT VECTOR
SW2VEC  RMB     2			* SWI2 INT. VECTOR
FIRVEC  RMB     2			* FIRQ INT. VECTOR
IRQVEC  RMB     2			* IRQ INT. VECTOR
SWIVEC  RMB     2			* SWI INT. VECTOR
NMIVEC  RMB     2			* NMI INT. VECTOR
USEVEC  RMB     2			* USER COMMAND VEC.
INVEC   RMB     2			* CONSOLE INPUT VEC.
OUTVEC  RMB     2			* CONSOLE OUTPUT VEC.
PRIVEC	RMB		2			* PRINTER DRIVER VEC.
EXTVEC	RMB		2			* AUX ROM JUMP TABLE EXTENSION
*
SAVECC  RMB     1			* TEMP REGISTER STORAGE
SAVEA   RMB     1			* FOR SWI INT. ROUTINE
SAVEB   RMB     1 
SAVEDP  RMB     1 
SAVEX   RMB     2 
SAVEY	RMB		2
SAVEU	RMB		2	
SAVEPC	RMB		2	
SAVES 	RMB		2	
SAVED 	RMB		2	
*
BEGADD  RMB     2			* RANGE ADDRESS
ENDADD  RMB     2
*
FINCNT	RMB		1			* NUMBER OF BYTES TO FIND
FINBY1	RMB		1			* STORAGE OF BYTE 1
FINBY2	RMB		1			* STORAGE OF BYTE 2
FINBY3	RMB		1			* STORAGE OF BYTE 3
FINBY4	RMB		1			* STORAGE OF BYTE 4
PRNORM	RMB		2			* 
PRFLAG	RMB		1			* PRINTER OUTPUT FLAG
LCMAP	RMB		1			* LC -> UC MAPPING BYTE
EXTFLG	RMB		1			* AUX ROM EXT. JUMP TABLE FLAG
XOFLAG	RMB		1			* XON/XOFF FLAG
XONORM	RMB		2
BYTE1	RMB		1			* GENERAL TEMP AREA
BYTE2	RMB		1			* GENERAL TEMP AREA
WORD1	RMB		2			* GEN TEMP FOR WORD
WORD2	RMB		2			* GEN TEMP FOR WORD
I2CDADD	RMB		2			* ADDRESS HI/LO BYTES FOR ADDRESSABLE I2C DEVICE SUCH AS SERIAL EEPROM
I2CBUFF	RMB		32			* BUFFER FOR I2C DATA
*
*
*
*
*
		ORG		$E000		* START OF SB ROM CODE
*
*
* ENTRY POINTS INTO MONITOR
*
COLDST	JMP		BOOT		* COLD ENTRY POINT TO MONITOR
WARMST	JMP		WARM		* WARM ENTRY POINT TO MONITOR
LOG		JMP		LOGON		* ENTRY FROM AUX ROM-SKIP INIT
*
*
* SUBROUTINES USED BY ALL ROUTINES 
* IN SMARTBUG
*
*
* INPUT A WORD FROM CONSOLE
*
*	USES BYTE ROUTINE TWICE TO GET A 16 BIT WORD
*	FROM KEYBOARD.  WORD IS IN X ON EXIT
*
WORD	BSR		BYTE		* READ 2 FRAMES
		STA		WORD1		* PUT HI BYTE IN
		BSR		BYTE		* GET NEXT BYTE
		STA		WORD1+1		* PUT LO BYTE IN
		LDX		WORD1		* GET WORD IN X
		RTS
*
* INPUT A BYTE FROM CONSOLE
*
*	GETS TWO KEYPRESSES, CONVERTS TO A TWO DIGIT
*	HEXIDECIMAL BYTE IN ACC A.  INVALID KEYS ARE 
*	CHECKED AND ERRORS ARE PASSED TO ERROR ROUTINE
*
BYTE    BSR		INCH		* GET A KEY
		BSR     ASCHEX		* CONVERT TO HEX CHAR.
		CMPA	#$FF		* ERROR?
		BEQ		BYERR1
		ASLA				* SHIFT TO HIGH HALF
        ASLA				* OF BYTE
        ASLA
        ASLA
        PSHS	A			* SAVE IT TEMP.
        BSR     INCH		* GET NEXT CHAR.
		BSR		ASCHEX
        CMPA	#$FF		* ERROR?
		BEQ		BYERR
		ADDA    ,S+			* COMBINE AND PULS 
        RTS					* EXIT WITH CHAR IN A
BYERR	PULS	A			* CLEAN STACK
BYERR1	JMP 	ERROR		* BAIL OUT
*
* ASCII TO HEX DIGIT
*
*	CONVERTS THE ASCII CHARACTER IN A TO A 4 BIT
*	HEX DIGIT AND PLACES THAT IN BITS 0 THRU 4 OF 
*	ACC A.  IF THE RESULT IS NOT A VALID HEX CHAR,
*	ACC A IS SET TO $FF.
*
ASCHEX  SUBA    #$30		* CONVERT ASCII  
        BMI     ASCERR		* LESS THAN 0?
        CMPA	#$09		* 
		BLE		ASCRTN		* BETWEEN 0 AND 9?
		CMPA	#$11		* 
		BMI		ASCERR		* LESS THAN A?
		CMPA	#$16
		BGT		ASCERR		* GREATER THAN F?
		SUBA	#$07		* ADJUST A-F
ASCRTN	RTS
ASCERR	LDA		#$FF		* SET UP THE FLAG
		RTS					* TO INDICATE NOT VALID
*
* OUTPUT TO CONSOLE (THRU RAM VECTOR)
*
OUTCH   JMP     [OUTVEC]
*
* INPUT FROM CONSOLE    (THRU RAM VECTOR)
*
INCH    JMP     [INVEC]
*
*
* COMMON ERROR RECOVERY POINT
*
ERROR   JMP     ERRREC
*
* OUTPUT HEX DIGITS
*
OUT2H	LDA		0,X
		BSR		OUTHL		* OUTPUT LEFT CHAR
		LDA		,X+	
		BRA		OUTHR
*
OUT4HS	BSR		OUT2H
OUT2HS	BSR		OUT2H
OUTS	LDA		#$20
		BRA		OUTCH		* PRINT FINAL SPACE
*
* OUTPUT LEFT HEX DIGIT AS ASCII
*
OUTHL   LSRA
        LSRA
        LSRA
        LSRA
*
* OUTPUT RIGHT HEX DIGIT AS ASCII
*
OUTHR   ANDA    #$0F		* MASK LEFTMOST NIBBLE
        ADDA    #$30		* CONVERT TO ASCII
        CMPA    #$39
        BLS     OUTCH
        ADDA    #$07		* CORRECT A-F
		BRA		OUTCH		* PRINT IT
*
* CONVERT LEFT HEX DIGIT TO ASCII
*
CONVHL  LSRA
        LSRA
        LSRA
        LSRA
*
* CONVERT RIGHT HEX DIGIT TO ASCII
*
CONVHR  ANDA    #$0F		* MASK LEFTMOST NIBBLE
        ADDA    #$30		* CONVERT TO ASCII
        CMPA    #$39
        BLS     CONVRTN
        ADDA    #$07		* CORRECT A-F
CONVRTN	RTS	
*
* PRINT ASCII STRING
*
PDATA1	LDA		,X+
		CMPA	#$04		* EOF MARKER?
		BNE		PDATA2
		RTS
PDATA2	BSR		OUTCH		* PRINT IT
		BRA		PDATA1		* GET MORE
*
* PRINT A CR/LF
*
CRLF	LDA		#$0D		* CR
		BSR		OUTCH
		LDA		#$0A		* LF
		BSR		OUTCH
		RTS
*
* ERROR RECOVERY
*
*	ALL DISCOVERED ERRORS COME HERE.  THIS ROUTINE
*	PRINTS A ' Eh?'.  THE STACK IS RESET AND
*	CONTROL IS PASSED TO THE WARM ROUTINE
*
ERRREC	JSR		CRLF		* LF DOWN TO GET A NEW LINE FOR THE Eh?
		LDX		#ERRSTR
		JSR		PDATA1		* PRINT ' Eh?'
		LDS		#STACK		* RESET STACK
		JMP		WARM		* RESTART AT PROMPT
*
* 
* SYSTEM ROUTINES CALLED BY COMMAND LOOP
*
*
*
* FROM - TO ROUTINE
*
FROMTO	JSR		CRLF
		LDX		#BEGSTR	
		JSR		PDATA1		* PRINT 'BEGINNING ADDRESS:'
		LDX		#ADDSTR
		JSR		PDATA1
		JSR		WORD		* GET THE ADDRESS
		STX		BEGADD
		JSR		CRLF
		LDX		#ENDSTR
		JSR		PDATA1		* PRINT 'ENDING ADDRESS:'
		LDX		#ADDSTR
		JSR		PDATA1
		JSR		WORD		* GET THE ADDRESS
		STX		ENDADD
		JSR		CRLF
		RTS
*
* HEX DUMP ROUTINE
*
HEXDMP	JSR		FROMTO		* GET START - END ADDRESS
		LDA		BEGADD+1
		ANDA	#$F0		* ROUND DOWN TO NEAREST
		STA		BEGADD+1	* WHOLE BOUNDRY
HEX		JSR		CRLF
		LDX		#BEGADD
		JSR		OUT4HS		* PRINT ADDRESS HEADER
		JSR		OUTS
		LDB		#$10		* SET COUNTER TO 16
		LDX		BEGADD	
HEX1	JSR		OUT2HS		* PRINT CONTENTS
		LEAX	-1,X		* BUMP COUNTER
		CMPX	ENDADD		* WAS THAT THE LAST?
		BNE		HEX2
		JSR		CRLF
		RTS
HEX2	LEAX	+1,X
		DECB				* BUMP COUNTER
		BNE		HEX1		* LINE FINISHED?
		STX		BEGADD		* SAVE CURRENT POINTER
		BRA		HEX			* START NEXT LINE
*
* FILL MEMORY WITH 1 BYTE CONSTANT
*
FILL	JSR		FROMTO			* GET START - END ADDRESS
		LDX		#WTHSTR 
		JSR		PDATA1
		JSR		BYTE			* GET FILL BYTE
		LDX		BEGADD			* GET START
FLOOP	STA		,X+				* STORE & BUMP
		CMPX	ENDADD			* WAS THAT THE LAST?
		BLS		FLOOP			* NO
		RTS
*
* ASCII INPUT ROUTINE
*
ASCIN   JSR     FROMTO          * GET ADDRESS RANGE
        JSR     CRLF
        LDX     BEGADD          * GET STARTING ADDRESS
ASCI2   JSR     INCH            * GET NEXT  CHAR
        STA     ,X+
        CMPA    #$04            * A CTRL D?
        BEQ     ASCI4           * YES SO EXIT
        CMPX    ENDADD          * CHECK FOR END OF BOUNDRY
        BNE     ASCI2
ASCI3   RTS
ASCI4	LDA		#$5E			* PRINT A '^D'
		JSR		OUTCH
		LDA		#$44
		JSR		OUTCH
		RTS						* AND EXIT
*
* ASCII OUTPUT ROUTINE
*
ASCOUT  JSR     FROMTO          * GET ADDRESS RANGE
        JSR     CRLF    
        LDX     BEGADD          * GET START ADDR
ASCO2   LDA     0,X             * GET NEXT CHAR
        CMPA    #$04            * A CTRL D?
        BEQ     ASCI4
        JSR     OUTCH           * SEND TO CONSOLE
        CMPX    ENDADD          * SEE IF DONE
        BEQ     ASCO3
        LEAX    +1,X            * BUMP INDEX
        BRA     ASCO2
ASCO3   RTS
*              
* GOTO TO USERS PROGRAM
*
GOTO    JSR     CRLF
        LDX     #ADDSTR
        JSR     PDATA1          * ASK FOR 'ADDRESS:'
        JSR     WORD			* GET ADDRESS
        JSR     CRLF
        JMP     0,X             * JUMP TO USER PROGRAM
*
* USER COMMAND ROUTINE
*
USER    JMP     [USEVEC]        * JUMP INDIRECT
*
* AUTO MEMORY LOAD
*
AUTO    JSR     CRLF    
        LDX     #ADDSTR         
        JSR     PDATA1          * ASK FOR 'ADDRESS:'
        JSR     WORD
        JSR     CRLF
AULOOP  JSR     CRLF
        STX     BEGADD          * TEMP SAVE
        LDX     #BEGADD 
        JSR     OUT4HS			* PRINT ADDRESS & SPACE
		LDX		BEGADD
		JSR		BYTE			* GET A BYTE
		STA		,X+				* PUT IN MEMORY'
		BRA		AULOOP
*
* EXAMINE & CHANGE MEMORY ROUTINE
*
EXAM	JSR		CRLF
		LDX		#ADDSTR			* ASK FOR 'ADDRESS:'
		JSR		PDATA1
		JSR		WORD	
		JSR		CRLF
EXLOOP	JSR		CRLF
		STX		BEGADD			* TEMP SAVE
		LDX		#BEGADD	
		JSR		OUT4HS			* PRINT ADDRESS & SPACE
		LDX		BEGADD
		JSR		OUT2HS			* PRINT VALUE AT LOCATION
INEX	JSR		INCH			* READ CONSOLE
		CMPA	#$46			* A F? (FORWARD)
		BEQ		FWRD
		CMPA	#$42			* A B? (BACK)
		BEQ		BACK
		CMPA	#$43			* A C? (CHANGE)
		BEQ		CHNG
		CMPA	#$0D			* A CR?
		BNE		INEX
		JSR		CRLF
		RTS
FWRD	BRA		EXLOOP			* POINTER BUMPED ALREADY
BACK	LEAX	-1,X			* GET PAST BUMPED POINTER
		LEAX	-1,X
		BRA		EXLOOP
CHNG	JSR		OUTS
		JSR		BYTE			* GET A NEW VALUE
		LEAX	-1,X			* GET BACK TO OPEN LOC.
		STA		,X
		JSR		OUTS
		BRA		EXLOOP
*
* NON DESTRUCTIVE MOVE ROUTINE
*
MOVE	JSR		CRLF
		LDX		#PRESTR			* ASK 'CURRENT LOCATION:'
		JSR		PDATA1
        JSR     FROMTO
        LDX     #NEWSTR         * ASK 'NEW LOCATION:'
        JSR     PDATA1
        JSR     WORD			* GET IT
        STX     WORD1
        CMPX    BEGADD          * IS IT LOWER OR HIGHER?
        BLO     MVBK            * LOWER
        BHI     MVFW
        RTS                     * NO MOVE - NEW = OLD
MVBK    TFR     X,Y             * Y= NEW START
        LDX     BEGADD          * X= OLD START
MVBKLP  LDA     ,X+
        STA     ,Y+
        CMPX    ENDADD          * IS THIS THE END?
        BLS     MVBKLP          * NO
        RTS
MVFW    LDD     ENDADD
        SUBD    BEGADD          * GET SIZE
        ADDD    WORD1           * GET NEW END
        TFR     D,Y             * Y= NEW END
        LDX     ENDADD          * X= OLD END
        LEAX    +1,X
        LEAY    +1,Y
MVFWLP  LDA     ,-X
        STA     ,-Y
        CMPX    BEGADD          * IS THIS THE START?
        BHI     MVFWLP          * NO
        RTS
*
* FIND 3 BYTE CONSTANT ROUTINE
*
FIND	JSR		CRLF
		LDX		#HOWSTR
		JSR		PDATA1			* ASK 'HOW MANY BYTES? '
		JSR		INCH
		SUBA	#$30			* CONVERT FROM ASCII
		BEQ		FIND5			* IF = 0      
		BMI		FIND5			* IF < 0                                 
		CMPA	#$03                                           
		BGT		FIND5                                           
		STA		FINCNT			* STORE # OF BYTES                 
		JSR		CRLF                                            
		LDX		#WHTSTR                                     
		JSR		PDATA1			* ASK ' WHAT BYTES?'                   
		LDB		FINCNT			* GET COUNT                              
		LDX		#FINBY1			* USES FINBY1 - FINBY4                    
FIENTR	PSHS	B                                     
		JSR		BYTE			* GET A VALUE                             
		PULS	B                                              
		STA		,X+				* SAVE IT                                 
		JSR		OUTS			* SPACE
		DECB                                               
		BNE		FIENTR			* ENTER MORE IF NEEDED                  
		JSR		FROMTO          * GET RANGE TO                  
		LDX		BEGADD			* SEARCH                                
FIND1	LDB		FINCNT			* MAIN FIND LOOP                  
		LDA		0,X				* GET FIRST BYTE                           
		CMPA	FINBY1                                          
		BNE		FIND4			* NO MATCH                               
		DECB                                                
		BEQ		FIND2			* FOUND 1 CORRECT                        
		LDA		1,X				* GET SECOND BYTE                          
		CMPA	FINBY2			* CHECK FOR SECOND MATCH              
		BNE		FIND4			* NO MATCH                               
		DECB	                                               
		BEQ		FIND2			* FOUND 2 CORRECT                        
		LDA		2,X				* GET THIRD                                
		CMPA	FINBY3			* CHECK FOR THIRD MATCH               
		BNE		FIND4			* NO MATCH                               
FIND2	STX		WORD1			* FOUND CORRECT BYTES               
		BSR		FIND5                                           
		LDX		#WORD1                                        
		JSR		OUT4HS			* PRINT ADDRESS                         
		JSR		OUTS                                            
		LDX		WORD1                                          
		LDB		#$03			* COUNT FOR 3 BYTES                       
FIND3	JSR		OUT2HS			* PRINT BYTES                     
		DECB                                                
		BNE		FIND3                                       
		LDX		WORD1			* RESTORE X REG.                         
FIND4	CMPX	ENDADD			* DONE?                            
		BEQ		FIND5                                           
		LEAX	+1,X			* BUMP ONE                               
		BRA		FIND1			* KEEP LOOKING                           
FIND5	JMP		CRLF			* CRLF & RTS                         
*
* XON / XOFF DRIVER INSTALLATION
*
XON		LDA		XOFLAG			* CHECK ENABLED/
		CMPA	#$00			* DISABLED STATUS
		BEQ		XOEN
		CLRA
		STA		XOFLAG
		LDX		XONORM			* REMOVE XON DRIVER
		STX		OUTVEC
		JSR		CRLF
		LDX		#XDSSTR			* PRINT DISABLED MESSAGE
		JSR		PDATA1
		JSR		CRLF
		RTS
XOEN	JSR		CRLF
		LDX		#XENSTR			* PRINT ENABLED MESSAGE
		JSR		PDATA1
		JSR		CRLF
		LDX		OUTVEC			* SAVE ORIGINAL OUTPUT
		STX		XONORM			* VECTOR
		LDX		#OUTXON
		STX		OUTVEC
		LDA		#$01			* SET XON DRIVER FLAG
		STA		XOFLAG
		JSR		CRLF
		RTS
*
* SERIAL PRINTER DRIVER
*
PRINT	LDA	PRFLAG		* CHECK ENABLED/
	CMPA	#$00		* DISABLED STATUS
	BEQ	PRON
	CLRA
	STA	PRFLAG	
	LDX	PRNORM		* REMOVE PRINTER
	STX	OUTVEC		* DRIVER
	JSR	CRLF
	LDX	#PRDSTR		* PRINT DISABLED MESSAGE
	JSR	PDATA1
	JSR	CRLF
	RTS
PRON	JSR	CRLF
	LDX	#PRNSTR		* PRINT ENABLED MESSAGE
	JSR	PDATA1
	JSR	CRLF
	LDX	OUTVEC		* SAVE ORIGINAL
	STX	PRNORM		* OUTPUT VECTOR
	LDX	#PROUT
	STX	OUTVEC
	LDA	#$01		* SET PRINT FLAG
	STA	PRFLAG		
	JSR	CRLF
	RTS
PROUT	PSHS	B		* SAVE B
PRO2	LDB	ACIASR		* CHECK DSR
	ANDB	#%01000000
	BNE	PRO2
PRO3	LDB	ACIASR		* CHECK FOR TRANSMITTER EMPTY
	ANDB	#%00010000
	BEQ	PRO2		* NOT CLEAR YET
	STA	ACIADR		* SEND CHAR
	PULS	B
	JMP	[PRNORM]	* ECHO TO DEFAULT
*
* CHANGE BAUD RATE (SY6551) 
*
BAUD	JSR		CRLF
		LDX		#BUDSTR		* PRINT AVAILABLE OPTIONS
		JSR		PDATA1
		JSR		INCH		* GET OPTION
		JSR		ASCHEX		* CONVERT TO HEX
		CMPA	#$FF		* ERROR IN INPUT?
		BEQ		BAERR
		STA		BYTE1
		LDA		ACIATR		* GET CURRENT BAUD RATE
		ANDA	#$F0		* CLEAR IT
		ORA		BYTE1		* ADD NEW
		STA		ACIATR		* SAVE NEW
		RTS
BAERR	JMP		ERROR		* BAD INPUT
*
* DOWNLOAD S1 S9 OBJECT FILES FROM HOST
*
DOWNS		JSR		CRLF
			LDX		#DWSSTR			* PRINT GREETING
			JSR		PDATA1
DW1			JSR		INCH			* GET A CHAR
			CMPA	#$53			* IS IT A 'S'?
			BNE		DW1				* NO SO DISCARD
			JSR		INCH			* GET SECOND CHAR
			CMPA	#$30			* IS IT 'S0'?
			BEQ		DW1				* YES SO IGNORE TITLE LINE
			CMPA	#$31			* IS IT 'S1'?
			BEQ		DWS1			* YES SO PROCESS IT
			CMPA	#$39			* IS IT 'S9'?
			BNE		DWERR			* NO SO PRINT ERROR
DWS9		JSR		BYTE			* GET NUMBER OF BYTES IN LINE
			TFR		A,B
DWS91		JSR		BYTE			* GET BYTE
			DECB					* THROW IT AWAY
			BNE		DWS91			* LOOP TO END
			LDX		#DWESTR			* PRINT 'TRANSFER COMPLETE'
			JSR		PDATA1
			RTS						* EXIT
DWERR		LDX		#DWRSTR			* PRINT 'TRANSFER ERROR'
			JSR		PDATA1
			RTS						* ABORT
DWS1		JSR		BYTE			* GET BYTE COUNT FOR LINE
			TFR		A,B
			DECB					* ADJUST COUNT
			JSR		WORD			* GET ADDRESS FOR LINE
			DECB					* ADJUST COUNT FOR 
			DECB					* ADDRESS
DWS11		JSR		BYTE			* GET BYTE
			STA		,X+				* STORE IT
			DECB					* END OF LINE?
			BNE		DWS11			* NO
			JSR		BYTE			* YES, IGNORE CHECKSUM
			JSR		CRLF
			BRA		DW1
*
* DOWNLOAD INTEL HEX FILES FROM HOST
*
DOWNI		JSR		CRLF
			LDX		#DWISTR			* PRINT GREETING
			JSR		PDATA1
DOWNILP		JSR		INCH			* GET A CHAR
			CMPA	#$3A			* IS IT A ':'? (START OF LINE)
			BNE		DOWNILP			* NO SO DISCARD
			JSR		BYTE			* GET NEXT TWO CHARS AND CONVERT TO BYTE
			CMPA	#$00			* IS IT $00 ? ASSUME LAST LINE (eof RECORD) HAS NO DATA
			BEQ		DOWNIEND		* YES, ITS THE LAST LINE SO IGNORE THE REST AND EXIT
			CMPA	#$10			* DOES LINE HAVE MORE THAN 16 BYTES'?
			BHI		DOWNIERR		* YES SO EXIT WITH ERROR
			TFR		A,B				* KEEP NUMBER OF BYTES IN B
			JSR		WORD			* GET ADDRESS FOR LINE IN X
			JSR		BYTE			* GET RECORD TYPE (00 OR 01)
			CMPA	#$00			* DATA RECORD?
			BNE		DOWNIERR		* NO SO ERROR
DOWNILPB	JSR		BYTE			* GET BYTE
			STA		,X+				* STORE IT
			DECB					* END OF LINE?
			BNE		DOWNILPB		* NO SO LOOP FOR MORE
			JSR		BYTE			* YES, IGNORE CHECKSUM
#			JSR		CRLF			* SENDING CRLF OR JUST LF SEEMS TO MESS UP THE PROPER READING OF THE FILE STREAM
			BRA		DOWNILP
DOWNIEND	JSR		WORD			* SKIP ADDRESS
			JSR		BYTE			* SKIP RECORD
			JSR		BYTE			* SKIP CHECKSUM
			LDX		#DWESTR			* PRINT 'TRANSFER COMPLETE'
			JSR		PDATA1
			RTS						* EXIT
DOWNIERR	LDX		#DWRSTR			* PRINT 'TRANSFER ERROR'
			JSR		PDATA1
			RTS						* ABORT
*
* COMPARE TWO MEMORY BLOCKS
*  USES A, B, X ,Y
*
CMPMEM		JSR		CRLF
			LDX		#FIRSTR		* ASK 'FIRST LOCATION:'
			JSR		PDATA1
			JSR     FROMTO		
			LDX		ENDADD
			LEAX	1,X			* CORRECT END ADDR BY ADDING 1
			STX		ENDADD
			LDX     #SECSTR     * ASK 'SECOND LOCATION:'
			JSR     PDATA1
			JSR     WORD		* GET IT
			TFR		X,Y			* MOVE 2ND BLOCK POINTER TO Y
CMPLOOP		JSR		CRLF
			LDX		#BEGADD		* GET 1ST BLOCK CURRENT POINTER
			JSR		OUT4HS		* PRINT ADDRESS HEADER
			JSR		OUTS
			LDB		#$10		* SET COUNTER TO 16
			LDX		BEGADD		* GET 1ST BLOCK POINTER IN X	
CMPLP2		LDA		,X+			* GET 1ST BLOCK VALUE
			CMPA	,Y+			* COMPARE TO 2ND BLOCK VALUE
			BNE		CMPDIFF		* DIFFERNT SO, PRINT THE SOURCE VALUE
			LDA		#$2E		* PRINT PERIOD SHOWING THEY COMPARE THE SAME
			JSR		OUTCH		* PRINT IT
			LDA		#$20		* PRINT 2 SPACES
			JSR		OUTCH
			JSR		OUTCH
CMPRTN		CMPX	ENDADD		* WAS THAT THE LAST?
			BNE		CMPINC		
			JSR		CRLF
			RTS
CMPINC		DECB				* BUMP COUNTER
			BNE		CMPLP2		* LINE FINISHED?
			STX		BEGADD		* SAVE CURRENT POINTER
			BRA		CMPLOOP		* START NEXT LINE
CMPDIFF		PSHS	A
			JSR		OUTHL		* PRINT FIRST DIGIT OF SOURCE BYTE TO FLAG ITS DIFFERNT 
			PULS	A
			JSR		OUTHL		* PRINT SECOND DIGIT OF SOURCE BYTE TO FLAG ITS DIFFERNT 
			JSR		OUTS
			BRA		CMPRTN		* JUMP BACK IN LOOP
*
* I2C RTC GET AND DISPLAY TIME/DATE/DAY OF WEEK, OPTIONALLY CHANGE CLOCK
*   USES A,X
*
RTCDIS		JSR		RTCGET		* GET RAW CLOCK DATA INTO I2CBUFF
			LDX		#CURTIM		* PRINT CURRENT TIME                 
			JSR		PDATA1		
			LDA		I2CBUFF+2	* GET HOURS
			ANDA	#%00111111	* MASK TO 2 DIGIT HOURS (24hr mode)
			JSR		OUTHL
			LDA		I2CBUFF+2	* GET HOURS
			ANDA	#%00111111	* MASK TO 2 DIGIT HOURS
			JSR		OUTHR
			LDA		#$3A		* PRINT COLON
			JSR		OUTCH
			LDA		I2CBUFF+1	* GET MINUTES
			ANDA	#%01111111	* MASK TO 7 BITS			
			JSR		OUTHL
			LDA		I2CBUFF+1	* GET MINUTES
			ANDA	#%01111111	* MASK TO 7 BITS
			JSR		OUTHR
			LDA		#$20		* PRINT SPACE
			JSR		OUTCH
			LDA		I2CBUFF+5	* GET MONTH
			ANDA	#%00011111	* MASK TO 5BITS FOR 0-31
			JSR		OUTHL
			LDA		I2CBUFF+5	* GET MONTH
			ANDA	#%00011111	* MASK TO 5 BITS FOR 0-31
			JSR		OUTHR
			LDA		#$2F		* PRINT FORWARD SLASH
			JSR		OUTCH			
			LDA		I2CBUFF+4	* GET DATE
			ANDA	#%00111111	* MASK TO 6 BITS FOR 0-31
			JSR		OUTHL
			LDA		I2CBUFF+4	* GET DATE
			ANDA	#%00111111	* MASK TO 6 BITS FOR 0-31
			JSR		OUTHR
			LDA		#$2F		* PRINT FORWARD SLASH
			JSR		OUTCH	
			LDA		I2CBUFF+6	* GET YEAR
			JSR		OUTHL
			LDA		I2CBUFF+6	* GET YEAR
			JSR		OUTHR
			LDA		#$20		* PRINT SPACE
			JSR		OUTCH
			LDA		I2CBUFF+3	* GET DAY OF WEEK
			JSR		OUTHR			
			LDX		#PRCRLF		* PRINT CRLF                
			JSR		PDATA1
			LDX		#NEWTIM		* PRINT NEW TIME               
			JSR		PDATA1
			LDA		#$00		* CLEAR SECONDS TO 00
			STA		I2CBUFF+0	
			BSR		RTCDISDCH	* GET 2 CHARS CONVERTED TO HEX
			ANDA	#%00111111	* MASK TO 6 BITS. 24HR MODE
			STA		I2CBUFF+2	* SAVE HOURS
			JSR 	INCH		* GET COLON BUT IGNORE IT
			BSR		RTCDISDCH	* GET 2 CHARS CONVERTED TO HEX
			ANDA	#%01111111	* MASK TO 7 BITS
			STA		I2CBUFF+1	* SAVE MINUTES
			JSR 	INCH		* GET SPACE BUT IGNORE IT
			BSR		RTCDISDCH	* GET 2 CHARS CONVERTED TO HEX
			ANDA	#%00011111	* MASK TO 5 BITS
			STA		I2CBUFF+5	* SAVE MONTH
			JSR 	INCH		* GET FORWARD SLASH BUT IGNORE IT
			BSR		RTCDISDCH	* GET 2 CHARS CONVERTED TO HEX
			ANDA	#%00111111	* MASK TO 6 BITS
			STA		I2CBUFF+4	* SAVE DATE
			JSR 	INCH		* GET FORWARD SLASH BUT IGNORE IT
			BSR		RTCDISDCH	* GET 2 CHARS CONVERTED TO HEX
			STA		I2CBUFF+6	* SAVE YEAR
			JSR 	INCH		* GET SPACE BUT IGNORE IT
			JSR		INCH		* GET A KEY	
			JSR		ASCHEX		* CONVERT TO HEX
			CMPA	#$FF		* ERROR IN INPUT?
			BEQ		RTCDISERR
			ANDA	#%00000111	* MASK TO 3 BITS
			STA		I2CBUFF+3	* SAVE DAY OF WEEK
			JSR		RTCSET
			RTS
RTCDISDCH	JSR		INCH		* GET A KEY (FIRST DIGIT)
			JSR		ASCHEX		* CONVERT TO HEX
			CMPA	#$FF		* ERROR IN INPUT?
			BEQ		RTCDISERR
			ASLA				* SHIFT TO HIGH HALF
			ASLA				* OF BYTE
			ASLA
			ASLA
			PSHS	A			* SAVE IT TEMP.
			JSR     INCH		* GET NEXT KEY (SECOND DIGIT)
			JSR		ASCHEX		* CONVERT TO HEX
			CMPA	#$FF		* ERROR IN INPUT?
			BEQ		RTCDISERR
			ADDA    ,S+			* COMBINE AND PULS
			RTS					* RETURN WITH 2 CHARACTERS IN A
RTCDISERR	JMP		ERROR		* BAD INPUT	
*
* WRITE DATA BLOCK TO PARALLEL EEPROM (UP TO 8k) WITH DATA POLLING ON WRITE (28C64/28C256) WITH BANK SWITCHING
*
EEPWRT		JSR		CRLF
			LDX		#PRESTR			* ASK 'CURRENT LOCATION:'
			JSR		PDATA1
			JSR     FROMTO
			LDX     #NEWSTR         * ASK 'NEW LOCATION:'
			JSR     PDATA1
			JSR     WORD			* GET IT
			STX     WORD1
			JSR		CRLF
			LDX		#BANKSTR		* ASK 'BANK 0-3):
			JSR     PDATA1
			JSR		INCH
			JSR		ASCHEX			* CONVERT ASCII TO 4 BIT NIBBLE
			ANDA	#%00000011		* MASK TO JUST A13, A14 BITS
			STA		BYTE1
			LDA		VIA2ORB			* GET VIA OUTPUT PINS
			ANDA	#%11111000		* FORCE /WE LOW, CLEAR A13, A14
			ORA		BYTE1			* SET A13, A14 PER BANK REQUESTED
			STA		VIA2ORB			* SET THE PINS
			LDX		WORD1			* EVALUATE DESTINATION ADDRESS
			CMPX    BEGADD          * IS IT LOWER OR HIGHER?
			BLO     EEPWRTBK        * LOWER
			BHI     EEPWRTFW		* HIGHER
			LDA		VIA2ORB			* IF SOMEHOW WE GET HERE, RESET /WE HIGH AND EXIT
			ORA		#%00000100
			STA		VIA2ORB			* SET THE /WE PIN
			RTS                     * NO MOVE - DEST = SRC
EEPWRTBK  	TFR     X,Y             * Y= DEST START.  MOVE FROM BEGINNING OF SOURCE BLOCK TO END
			LDX     BEGADD          * X= SRC START
EEPWRTLP	LDA     ,X+				* INDEXED POST INCREMENT
			STA     ,Y				* DONT INC Y YET (SE NEED IT FOR THE COMPARE IN POLLING)
EEPWRTCK	CMPA	,Y				* CHECK IF WRITE FINISHED (D7 BIT IS COMPLEMENT IN A POLL UNTIL WRITE FINISHED)
			BNE		EEPWRTCK		* LOOP BACK UNTIL VALUE MATCHES
			LEAY    +1,Y			* NOW INC Y
			CMPX    ENDADD          * IS THIS THE END?
			BLS     EEPWRTLP        * NO
			LDA		VIA2ORB			* RESET /WE HIGH AND EXIT, LEAVE BANK AS SELECTED
			ORA		#%00000100
			STA		VIA2ORB			* SET THE /WE PIN
			RTS
EEPWRTFW   	LDD     ENDADD			* MOVE FROM END OF SOURCE BLOCK TO BEGINNING
			SUBD    BEGADD          * GET SIZE
			ADDD    WORD1           * GET NEW END
			TFR     D,Y             * Y= DEST END
			LDX     ENDADD          * X= SRC END
			LEAX    +1,X			* INDEXED DECREMENT IS PRE DEC, SO BUMP SRC AND DEST TO START AT PROPER LOCATION
			LEAY    +1,Y
EEPWRTFWLP 	LDA     ,-X
			STA     ,-Y				* INDEXED DECREMENT IS PRE DECERMENT SO A IS STILL VALID DATA FOR COMPARE
EEPWRTFWCK	CMPA	,Y				* CHECK IF WRITE FINISHED (D7 BIT IS COMPLEMENT IN A POLL UNTIL WRITE FINISHED)
			BNE		EEPWRTFWCK		* LOOP BACK UNTIL VALUE MATCHES
			CMPX    BEGADD          * IS THIS THE START?
			BHI     EEPWRTFWLP      * NO
			LDA		VIA2ORB			* RESET /WE HIGH AND EXIT, LEAVE BANK AS SELECTED
			ORA		#%00000100
			STA		VIA2ORB			* SET THE /WE PIN
			RTS
*
* READ DATA BLOCK FROM PARALLEL EEPROM (UP TO 8k) (28C64 or 28C256) WITH BANK SWITCHING
*
EEPRED		JSR		CRLF
			LDX		#PRESTR			* ASK 'CURRENT LOCATION:'
			JSR		PDATA1
			JSR     FROMTO
			LDX     #NEWSTR         * ASK 'NEW LOCATION:'
			JSR     PDATA1
			JSR     WORD			* GET IT
			STX     WORD1
			JSR		CRLF
			LDX		#BANKSTR		* ASK 'BANK 0-3):'
			JSR     PDATA1
			JSR		INCH
			JSR		ASCHEX			* CONVERT ASCII TO 4 BIT NIBBLE
			ORA		#%00000100		* FORCE /WE HI FOR READ
			ANDA	#%00000111		* MASK TO JUST /WE, A13, A14 BITS
			STA		BYTE1
			LDA		VIA2ORB			* GET VIA OUTPUT PINS
			ANDA	#%11111100		* FORCE /WE HI, CLEAR A13, A14
			ORA		BYTE1			* SET A13, A14 PER BANK REQUESTED
			STA		VIA2ORB			* SET THE PINS
			LDX		WORD1			* EVALUATE DESTINATION ADDRESS
			CMPX    BEGADD          * IS IT LOWER OR HIGHER?
			BLO     EEPREDBK        * LOWER
			BHI     EEPREDFW		* HIGHER
			LDA		VIA2ORB			* IF SOMEHOW WE GET HERE, RESET /WE HIGH AND EXIT
			ORA		#%00000100
			STA		VIA2ORB			* SET THE /WE PIN
			RTS                     * NO MOVE - DEST = SRC
EEPREDBK  	TFR     X,Y             * Y= DEST START.  MOVE FROM BEGINNING OF SOURCE BLOCK TO END
			LDX     BEGADD          * X= SRC START
EEPREDLP	LDA     ,X+				* INDEXED POST INCREMENT
			STA     ,Y+				* SAVE AND INC Y 
			CMPX    ENDADD          * IS THIS THE END?
			BLS     EEPREDLP        * NO
			LDA		VIA2ORB			* RESET /WE HIGH AND EXIT, LEAVE BANK AS SELECTED
			ORA		#%00000100
			STA		VIA2ORB			* SET THE /WE PIN
			RTS
EEPREDFW   	LDD     ENDADD			* MOVE FROM END OF SOURCE BLOCK TO BEGINNING
			SUBD    BEGADD          * GET SIZE
			ADDD    WORD1           * GET NEW END
			TFR     D,Y             * Y= DEST END
			LDX     ENDADD          * X= SRC END
			LEAX    +1,X			* INDEXED DECREMENT IS PRE DEC, SO BUMP SRC AND DEST TO START AT PROPER LOCATION
			LEAY    +1,Y
EEPREDFWLP 	LDA     ,-X
			STA     ,-Y				* INDEXED DECREMENT IS PRE DECERMENT SO A IS STILL VALID DATA FOR COMPARE
			CMPX    BEGADD          * IS THIS THE START?
			BHI     EEPREDFWLP      * NO
			LDA		VIA2ORB			* RESET /WE HIGH AND EXIT, LEAVE BANK AS SELECTED
			ORA		#%00000100
			STA		VIA2ORB			* SET THE /WE PIN
			RTS
*
* VERSION ROUTINE
*
*	THIS COMMAND PRINTS THE VERSIONS
*	OF THE ROMS FOUND.  THE SMARTBUG
*	VERSION IS ALWAYS PRINTED, THE AUX
*	ROM VERSION IS PRINTED IF FOUND
*
VERSIN		JSR		CRLF
		LDX		#VERSTR		* PRINT SB STRING
		JSR		PDATA1
		LDX		#SBVERS		* PRINT SB VERSION
		JSR		PDATA1
		LDX		#VERST1		* PRINT AUX STRING
		JSR		PDATA1
		LDX		EXTVEC		* CHECK FOR AUX ROM
		BNE		VERFND		* YES THERE IS AUX
		LDX		#AUXFLG		* CHECK FOR AUTOSTART
		LDY		#EJMP		* ROM VECTOR
VERLOP	LDA		,X+			* 
		CMPA	,Y+			* 
		BNE		VERNO		* VECTOR
		CMPX	#AUXFLG+4	* FLAG IS A '6809'
		BNE		VERLOP		* AT 6 BYTE OFFSET IN ROM
VERFND	LDX		#AUXVER		* PRINT THE AUX ROM
VERFLP	LDA		,X+			* VERSION NUMBER
		JSR		OUTCH
		CMPX	#AUXVER+4	* DONE ALL 4 CHARS?
		BNE		VERFLP		* DO NEXT CHAR
		JSR		CRLF
		RTS
VERNO	LDX		#VERST2		* PRINT NONE SINCE NO
		JSR		PDATA1		* AUX ROM WAS FOUND
		RTS
*
* BREAKPOINT HANDLER
*
BKPNT	LDX	#SAVECC		* MAKE A WORKING
		CLRA			* COPY OF ALL THE
BKLOOP	LDB	A,S			* REGISTERS
	STB	A,X
	INCA
	CMPA	#$0C
	BNE	BKLOOP
	LDD	SAVEA
	STD	SAVED
	TFR	S,D
	ADDD	#$000C		* ADJUST STACK FOR
	STD	SAVES		* BEFORE SWI
	LDX	SAVEPC		* ADJUST PC FOR
	LEAX	-1,X		* BEFORE SWI
	STX	BEGADD		* MAKE A COPY
      	JSR	CRLF
	JSR	CRLF
	LDX	#BPSTR		* SAY 'BREAKPOINT ENCOUNTERED AT $'
	JSR	PDATA1
	LDX	#BEGADD		* PRINT ADDRESS
	JSR	OUT4HS
	JSR	CRLF
	JSR	CRLF
PREG	LDX	#ASTR		* PRINT A REGISTER
	JSR	PDATA1
	LDX	#SAVEA
	JSR	OUT2H
	JSR	CRLF
	LDX	#BSTR		* PRINT B REG.
	JSR	PDATA1
	LDX	#SAVEB
	JSR	OUT2H
	JSR	CRLF
	LDX	#DSTR		* PRINT D REG.
	JSR	PDATA1
	LDX	#SAVED
	JSR	OUT4HS
	JSR	CRLF
	LDX	#XSTR		* PRINT X REG.
	JSR	PDATA1
	LDX	#SAVEX
	JSR	OUT4HS
	JSR	CRLF
	LDX	#YSTR		* PRINT Y REG.
	JSR	PDATA1
	LDX	#SAVEY
	JSR	OUT4HS
	JSR	CRLF
	LDX	#SSTR		* PRINT S REG.
	JSR	PDATA1
	LDX	#SAVES
	JSR	OUT4HS
	JSR	CRLF
	LDX	#USTR		* PRINT U REG.
	JSR	PDATA1
	LDX	#SAVEU
	JSR	OUT4HS
	JSR	CRLF
	LDX	#PCSTR		* PRINT PC REG.
	JSR	PDATA1
	LDX	#SAVEPC
	JSR	OUT4HS
	JSR	CRLF
	LDX	#CCSTR		* PRINT CC REG.
	JSR	PDATA1
	LDX	#SAVECC
	JSR	OUT2H
	JSR	CRLF
	LDX	#DPSTR		* PRINT DP REG.
	JSR	PDATA1
	LDX	#SAVEDP
	JSR	OUT2H
	JSR	CRLF
BPCNT	JSR	CRLF
	LDX	#BPCSTR		* SAY 'CONTINUE PROGRAM OR
	JSR	PDATA1		* EXIT TO MONITOR <C/E>?'
	JSR	INCH
	CMPA	#'E'
	BEQ	BPEXT
	CMPA	#'C'
	BNE	BPCNT		* NOT VALID TRY AGAIN
BPRES	JSR	CRLF
	LDX	#BPRSTR		* ASK 'REPLACE BREAKPOINT WITH
	JSR	PDATA1		* WHAT OPCODE?'
	JSR	BYTE
	LDX	BEGADD
	STA	0,X
	LDX 	SAVEPC          * CHANGE RTI ADDRESS
	LEAX	-1,X 		* CHANGE SO AS TO 
	STX 	SAVEPC		* START AT OPCODE
	LDX     #SAVECC		* RESTORE REGISTERS
	CLRA
BKLP1   LDB	A,X
	STB	A,S  
	INCA
	CMPA	#$0C
	BNE	BKLP1 
	RTI			* RETURN
BPEXT	LDS 	#STACK		* RESET STACK TO BE SAFE
	JMP	WARM		* ASSUME EVERYTHING INITALIZE
*
* HELP SCREEN
*
HELP	LDX		#HLPSTR		* GET TEXT ADDRESS
		JSR		PDATA1		* PRINT IT
		RTS
*
* EXIT BACK TO PRIMARY TASK
*
EXITR	JSR		CRLF
		JSR		CRLF
		LDX		#EXISTR		* PRINT GOODBYE MESSAGE
		JSR		PDATA1
		JMP		BOOT		* RESTART AUX ROM (BOOT)
*                                                    
* RESTART ROUTINE                                    
*                                                    
BOOT	LDS		#STACK			* SET STACK                         
		ORCC	#%01010000		* DISABLE INTERRUPTS                
		LDU		#RAMTOP			* SET U STACK (NOT USED)
		LDA		#$00			* SET DIRECT PAGE TO ZERO
		TFR		A,DP
		LDX		#INEEE			* SET UP IO VECTORS
		STX		INVEC
		LDX		#OUTEEE
		STX		OUTVEC                                        
		CLRA					* RESET PRINTER FLAG
		STA		PRFLAG			* TO NO PRINTER CONDITION
		STA		LCMAP			* DISABLE LC-UC MAPPING
		STA		XOFLAG			* SET TO NO XON/XOFF
		STA		EXTVEC			* CLEAR EXTERNAL TABLE
		STA		EXTVEC+1		* VECTOR
		LDX		#INTRTN			* SET UP COMMON                       
		STX		SW3VEC			* RTI FOR ALL                      
		STX		SW2VEC			* INTERRUPTS                           
		STX		FIRVEC                                        
		STX		IRQVEC                                          
		STX		NMIVEC
		LDX		#BKPNT			* SWI FOR BREAKPOINT USE               
		STX		SWIVEC                                          
		LDX		#RTSRTN			* SET UP DUMMY
		STX		USEVEC      	* USER VECTOR                   
		JSR		INIZA			* INITALIZE DEFAULT ACIA
		JSR		INITVIA2B		* INITIALZE VIA2 PORT B PINS FOR EEPROM BANK SWITCHING AND /WE
		JSR 	I2CINIT			* INITIALIZE THE I2C CHIP PCF8584 (temp disable for debugging OR IF CHIP IS NOT INSTALLED)
TABCHK	LDX		#AUXTFL			* CHECK FOR EXTENSION
		LDY		#ETAB			* TO COMMAND TABLE IN
TABLOP	LDA		,X+				* AUX ROM. IF SO SET
		CMPA	,Y+				* EXTVEC TO ADDRESS
		BNE		ROMCHK			* NO SO SKIP
		CMPX	#AUXTFL+4		* DONE?
		BNE		TABLOP			* NO SO CHECK NEXT
		LDX		AUXTBL			* YES, GET VECTOR
		STX		EXTVEC			* AND SAVE IT
ROMCHK	LDX		#AUXFLG			* CHECK FOR AUTOSTART
		LDY		#EJMP			* ROM  AND 
RELOOP	LDA		,X+				* IF PRESENT JUMP
		CMPA	,Y+				* TO ITS COLD START
		BNE		LOGON			* VECTOR
		CMPX	#AUXFLG+4		* FLAG IS A '6809'
		BNE		RELOOP			* AT 6 BYTE OFFSET IN ROM
		JMP		[AUXCLD]		* JUMP INDIRECTLY
*                                                   
* MONITOR COMMAND LOOP                               
*                                                    
LOGON	LDX	#SMTSTR   	* PRINT GREETING                  
		JSR	PDATA1                                        
		LDX	#SM1STR                                         
		JSR	PDATA1                                         
		LDX	#SM2STR                                         
		JSR	PDATA1                                          
WARM	JSR 	CRLF                                       
		JSR	CRLF                                            
		LDA	#$2D  		* PRINT THE PROMPT                      
		JSR 	OUTCH                                          
		LDA	#$3E  		* A '->'                                
		JSR	OUTCH                                           
		JSR	INCH		* GET FIRST COMMAND                       
		TFR	A,B 	                                           
		JSR	INCH		* GET 2ND CHAR                            
		EXG	A,B                                             
LOOKUP	LDX	#COMTAB		* GET LOOK UP TABLE                    
		JSR	SEARCH		* CHECK DEFAULT TABLE
		CMPX	#$0000		* NOTHING YET?
		BNE	LOKFND		* FOUND ONE
		LDX	EXTVEC 		* IS THERE A AUX TABLE?
		CMPX	#$0000		
		BEQ	NOFND		* NO SO EXIT
		JSR	SEARCH		* CHECK THE AUX TABLE
		CMPX	#$0000		* NOTHING HERE EITHER?
		BNE	LOKFND		* FOUND ONE
NOFND	JMP	ERRREC		* PRINT A ' Eh?'
LOKFND	JSR	CRLF                     
		JSR	0,X                                         
		BRA	WARM		* ON RETURN RE-QUERY                     
*
* SEARCH COMMAND TABLE
*
*	SEARCHES A COMMAND TABLE FOR A MATCH
*	UPON ENTRY X= TABLE ADDRESS, D= TWO
*	ASCII CHARACTERS TO FIND.  UPON EXIT
*	X= $0000 IF NO MATCH WAS FOUND, X= $yyyy
*	IF MATCH OCCURED. yyyy IS THE ROUTINES ADDR.
*	USES Y REGISTER.
*
SEARCH	LDY		#$FFFF			* EOT FLAG
SERLOP	CMPY	0,X				* CHECK FOR END
		BEQ		SEREXT			* YES
		CMPD	,X++			* CHECK FOR MATCH
		BEQ		SERFND			* YES
		LEAX	+2,X			* BUMP POINTER
		BRA		SERLOP			* CHECK NEXT
SERFND	LDX		0,X				* GET ADDRESS
		RTS						* EXIT
SEREXT	LDX		#$0000			* CLEAR X
		RTS						* EXIT
*                          
SMTSTR	FCB	$0D,$0A,$0A,$09
      	FCC	'SMARTBUG /09 '
SBVERS	FCC	'v1.27a-S69'
		FCB	$0D,$0A,$04                  
SM1STR	FCB	$09                             
		FCC	'  WRITTEN 09/12/23'                        
		FCB 	$0D,$0A,$04                 
SM2STR	FCB	$09                               
		FCC	'   BY JEFF EASTON'                           
		FCB	$04                  
EJMP  	FCC	'6809'				* AUX ROM AUTOSTART
ETAB	FCC	'ETAB'				* AUX ROM TABLE
*
INTRTN	RTI
RTSRTN	RTS
*
COMTAB	FCC	'HE'
		FDB	HEXDMP
		FCC	'FL'
		FDB	FILL
		FCC	'AI'
		FDB	ASCIN
		FCC	'AO'
		FDB	ASCOUT
		FCC	'GO'
		FDB	GOTO
		FCC	'UR'
		FDB	USER
		FCC	'AU'
		FDB	AUTO
		FCC	'EX'
		FDB	EXAM
		FCC	'MO'
		FDB	MOVE
		FCC	'FI'
		FDB	FIND
		FCC	'??'
		FDB	HELP
		FCC	'PR'
		FDB	PRINT
		FCC	'BR'
		FDB	BAUD
		FCC	'XX'
		FDB	EXITR
		FCC	'DS'
		FDB	DOWNS
		FCC	'DI'
		FDB	DOWNI
		FCC	'VR'
		FDB	VERSIN
		FCC 'CL'
		FDB RTCDIS
		FCC 'CP'
		FDB CMPMEM
		FCC 'EW'
		FDB EEPWRT
		FCC 'ER'
		FDB EEPRED
		FDB	$FFFF				* EOF MARKER
*
*  INIT VIA2 PORT B PINS 0-2 FOR EEPROM BANK SWITCHING AND WRITE ENABLE FOR THE 28C64/28C256 EEPROM.  
*  AT POWERUP THESE ARE ALL SET TO INPUTS WHICH IS SEEN AS A HI LOGIC ON THE EEPROM, SO
*  BY DEFAULT BANK 3 IS SET AND WRITING IS DISABLED.  INIT WILL CHANGE THE VIA PINS TO OUTPUTS ALL AT HI
*  TO MIMICK THIS.
*  VIA2PB0 -> EEPROM A13 (PIN 26)
*  VIA2PB1 -> EEPROM A14 (PIN 1)
*  VIA2PB2 -> /WE        (PIN 27)
*
* REMEMBER TO SET THE 3 JUMPERS ON THE PCB TO THE PBx POSITION IF USING THIS OPTION
*

INITVIA2B	LDA		VIA2DRB			* SET PB0-PB2 AS OUTPUTS	
			ORA		#%00000111		* FOR /WE AND BANK SWITCHING EEPROM A13, A14
			STA		VIA2DRB			
			LDA		VIA2ORB			* GET PORT B OUTPUTS
			ORA		#%00000111		* SET PB0-PB2 HI
			STA		VIA2ORB
			RTS
*
* DEFAULT CONSOLE ROUTINES.  USUALLY COMMENT OUT THE ONE (3) NOT USED
*
*
* DEFAULT CONSOLE ROUTINES  >>> SY6551 ACIA <<<
*
*
* INITIALIZE ACIA   >>> SY6551 ACIA <<<
*
INIZA	LDA		#%00011111		* 1 STP, 8 DTA, INT BRG, 19,200
		STA		ACIATR
		LDA		#%00001011		* NO PARITY, TX EN, RTS LO, IRQ DIS
		STA		ACIACR
		RTS
*
* GET CHARACTER FROM ACIA  >>> SY6551 ACIA <<<
*
INEEE	LDA		ACIASR			* CHECK FOR RECEIVED
		ANDA	#%00001000
		BEQ		INEEE
		LDA		ACIADR			* GET CHAR
		ANDA	#$7F			* MASK TO ASCII
		CMPA	#$03			* CTRL-C?
		BEQ		CTRLC
		CMPA	#$60			* CHECK FOR LOWER CASE
		BLO		INEE2
		SUBA	LCMAP			* APPLY LC-UC MAPPING
INEE2	JMP		[OUTVEC]		* ECHO TO OUTPUT
*
* SEND CHARACTER TO ACIA  >>> SY6551 ACIA <<<
*                                       
OUTEEE	PSHS	B                           
OUTLP	LDB		ACIASR			* CHECK FOR READY
		ANDB	#%00010000
		BEQ		OUTLP			* NOT READY YET                                        
		STA		ACIADR                         
		PULS	B                   
		RTS                       
*
* DEFAULT CONSOLE ROUTINES  >>> MC6850 ACIA <<<
*
*
* INITIALIZE ACIA   >>> MC68050 ACIA <<<
*
*INIZA	LDA		#%00000011		* RESET 6850
*		STA		ACIA8CR
*		LDA		#%00010101		* SET 115.2K BAUD AT 8N1 IRQ DIS (DIV 16 CLOCK)
*		STA		ACIA8CR
*		RTS
*
* GET CHARACTER FROM ACIA  >>> MC6850 ACIA <<<
*
*INEEE	LDA		ACIA8CR			* CHECK FOR RECEIVED
*		ANDA	#%00000001		* BY CHECKING RDRF BIT
*		BEQ		INEEE
*		LDA		ACIA8DR			* GET CHAR
*		ANDA	#$7F			* MASK TO ASCII
*		CMPA	#$03			* CTRL-C?
*		BEQ		CTRLC
*		CMPA	#$60			* CHECK FOR LOWER CASE
*		BLO		INEE2
*		SUBA	LCMAP			* APPLY LC-UC MAPPING (SUB $20)
*INEE2	JMP		[OUTVEC]		* ECHO TO OUTPUT
*
* SEND CHARACTER TO ACIA  >>> MC6850 ACIA <<<
*                                       
*OUTEEE	PSHS	B                           
*OUTLP	LDB		ACIA8CR			* CHECK FOR READY
*		ANDB	#%00000010		* BY CHECKING TDRE BIT
*		BEQ		OUTLP			* NOT READY YET                                        
*		STA		ACIA8DR                         
*		PULS	B                   
*		RTS    
*
CTRLC	LDS		#STACK			* RESET STACK FOR SAFTEY
		LDA		#$5E			* PRINT '^C'
		JSR		OUTCH
		LDA		#$43
		JSR		OUTCH
		JMP		WARMST			* RE-ENTER MONITOR
*
*
* XON/XOFF OUTPUT CHAR  >>> SY6551 ACIA <<<
*
OUTXON	PSHS	A				* SUPPORTS XON/XOFF
OUTEE1	LDA		ACIASR			* SEE IF ANY CHARS. RECEIVED
		ANDA	#%00001000
		BNE		OUTEE3			* YES SO BR TO EXCEPTION HANDLER
OUTEE2	LDA		ACIASR			* RECHECK STATUS FOR SEND
		ANDA	#%00010000
		BEQ		OUTEE1			* NOT READY SO RETRY
		PULS	A				* GET CHAR BACK
		STA 	ACIADR			* SEND IT
		RTS
OUTEE3	LDA		ACIADR			* EXCEPTION HANDLER
		CMPA	#$20			* SEE IF A CONTROL CODE
		BHS		OUTEE2			* NO SO IGNORE
OUTEE4	CMPA	#$03			* CTRL C?
		BEQ		CTRLC			* YES SO HANDLE
		CMPA	#$13			* CTRL S?
		BNE		OUTEE2			* NO SO DISCARD
CTRLS	LDA		ACIASR			* WAIT FOR NEXT CHAR
		ANDA	#%00001000
		BEQ		CTRLS			* NOTHING YET
		LDA		ACIADR			* GET INCOMING CHAR.
		CMPA	#$03			* CTRL C?
		BEQ		CTRLC			* YES SO ABORT
		CMPA	#$11			* CTRL Q?
		BNE		CTRLS			* NO SO IGNORE
		BRA		OUTEE2			* YES SO CONTINUE SENDING
*
* INIT PCF8584
*   USES A
*
I2CINIT	LDA		#$80			* PIN - SX = OWN ADDRESS
		STA		P8584S1
		NOP						* WAIT REQUIRED 6 CLOCKS FOR SUBSEQUENT ACCESS
		NOP						* REQUIRED FOR 8MHz OR GREATER CLOCK
		NOP
		LDA		#$55			* OWN ADDRESS
		STA		P8584SX
		NOP						* WAIT 6 CLOCKS
		NOP
		NOP
		LDA		#$A0			* PIN+ES1 - SX = CLOCK REGISTER
		STA		P8584S1
		NOP						* WAIT 6 CLOCKS
		NOP
		NOP
		LDA		#$18			* 8MHz EXT OSC, 90kHz SCL FREQ		
		STA		P8584SX
		NOP						* WAIT 6 CLOCKS
		NOP
		NOP
		LDA		#$C1			* PIN+ESO+ACK
		STA		P8584S1

*		JSR		I2CBUSY			* MIGHT HANG IN I2CBUSY IF CHIP IS MISSING
		NOP						* WAIT 6 CLOCKS
		NOP
		NOP
		RTS
*
* WAIT FOR PCF8584 READY
*
I2CBUSY	PSHS	A				* SAVE A
I2CBSY2	LDA		P8584S1
		ANDA	#$01			* CHECK BUSY BIT
		BEQ		I2CBSY2
		PULS	A				* RESTORE A
		RTS
*
* I2C READ START
*  A = SLAVE ADDRESS ($00-$FF)
*   USES B
*
I2CREAD	LDB		P8584S1
		BPL		I2CREA1			* BUS OPERATION IS CURRENTLY ACTIVE (PIN SET)?

* START NEW BUS OPERATION
		JSR		I2CBUSY
		ORA		#%00000001		* SET READ BIT
		STA		P8584SX			* SET SLAVE ADDRESS
		LDA		#$C5			* PIN+ESO+STA+ACK - "START"
		STA		P8584S1
		BRA		I2CREAW			* WAIT FOR COMMAND TO COMPLETE

* RESTART BUS OPERATION
I2CREA1	LDB		#$45			* ESO+STA+ACK - "START" WITHOUT PREVIOUS "STOP"
		STB		P8584S1
		ORA		#%00000001		* SET READ BIT
		STA		P8584SX			* SET SLAVE ADDRESS
I2CREAW	LDA		P8584S1
		BMI		I2CREAW			* PIN SET? DATA SENT?
		ANDA	#$08			* MASK OUT LRB
		BNE		I2CREAE			* ERROR - SLAVE DID NOT ACK
		LDA		P8584SX			* DUMMY READ TO CLEAR DATA REG FROM SLAVE ADDRESS
		ORCC 	#%00000001
		RTS
I2CREAE
		ANDCC 	#%11111110
		RTS
*
* I2C WRITE START
*  A = SLAVE ADDRESS ($00-$FF)
*
I2CWRIT	PSHS	B				* SAVE B
		TFR		A,B				* MOVE SLAVE ADDR TO B
		JSR		I2CBUSY
		ANDB	#%11111110		* SET WRITE BIT
		STB		P8584SX			* SET SLAVE ADDRESS

		LDA		#$C5			* PIN+ESO+STA+ACK - "START"
		STA		P8584S1

I2CWRIW	LDA		P8584S1
		BMI		I2CWRIW			* PIN SET? DATA SENT?
		ANDA	#$08			* MASK OUT LRB
		BNE		I2CWRIE			* ERROR - SLAVE DID NOT ACK
		PULS	B 				* RESTORE B
		ORCC 	#%00000001		* SET CARRY FOR OK
		RTS
I2CWRIE	PULS	B 				* RESTORE B
		ANDCC 	#%11111110		* CLEAR CARRY FOR ERROR
		RTS
*
* I2C STOP
*
I2CSTOP	PSHS	A 				* SAVE A
I2CSTPL	LDA	P8584S1
		BMI		I2CSTPL			* PIN SET? DATA SENT?
I2CSTPF	LDA		#$C3			* PIN+ES0+STO+ACK - "STOP"
		STA		P8584S1
		PULS	A				* RESTORE A
		RTS
*
* I2C RX MULTIPLE-BYTES
*  A = NUMBER OF BYTES TO READ
*  X = DATA BUFFER
*
I2CRX	PSHS	B				* SAVE B
		TFR		A,B				* MOVE # BYTES TO B
I2CRXLP	LDA		P8584S1
		BMI		I2CRXLP			* PIN SET? DATA RECEIVED?
		ANDA	#$08			* MASK OUT LRB
		BNE		I2CRXER			* ERROR - SLAVE DID NOT ACK
		TSTB					* CHECK IF THIS IS THE FINAL BYTE
		BNE		I2CRX1
		LDA		#$40			* ESO - SEND "NACK" FOR FINAL BYTE
		STA		P8584S1
I2CRX1	LDA		P8584SX			* READ DATA FROM BUS
		STA		,X
		LEAX 	1,X
		DECB
		CMPB	#$FF
		BNE		I2CRXLP			* MORE BYTES TO READ?
		PULS	B 				* RESTORE B
		ORCC 	#%00000001		* SET CARRY FOR OK
		RTS
I2CRXER	PULS	B 				* RESTORE B
		ANDCC 	#%11111110		* CLEAR CARRY FOR ERROR
		RTS
*
* I2C TX MULTIPLE-BYTES
*  A = NUMBER OF BYTES TO SEND
*  X = POINTS TO DATA BUFFER
*
I2CTX	PSHS	B				* SAVE B
		TFR		A,B				* MOVE # BYTES TO B
I2CTXLP	LDA		,X
		LEAX 	1,X
		STA		P8584SX			* SEND DATA TO BUS
I2CTXW	LDA		P8584S1
		BMI		I2CTXW			* PIN SET? DATA SENT?
		ANDA	#$08			* MASK OUT LRB
		BNE		I2CTXER			* ERROR - SLAVE DID NOT ACK
		DECB
		CMPB	#$FF
		BNE		I2CTXLP			* MORE BYTES TO WRITE?
		PULS	B 				* RESTORE B
		ORCC 	#%00000001		* SET CARRY FOR OK
		RTS
I2CTXER	PULS	B 				* RESTORE B
		ANDCC 	#%11111110		* CLEAR CARRY FOR ERROR
		RTS
*
* I2C TX ONE BYTE
*  A = BYTE TO SEND
*
I2CTXONE	STA		P8584SX			* SEND DATA TO BUS
I2CTXWONE	LDA		P8584S1
			BMI		I2CTXWONE		* PIN SET? DATA SENT?
			ANDA	#$08			* MASK OUT LRB
			BNE		I2CTXERONE		* ERROR - SLAVE DID NOT ACK
			ORCC 	#%00000001
			RTS
I2CTXERONE	ANDCC 	#%11111110
			RTS
*
* I2C RTC GET TIME INTO I2CBUFF
*   USES A,X
*
RTCGET	LDA		#RTCADDR		* SET ADDRESS REGISTER TO $00
		JSR		I2CWRIT			* START WRITE
		LDA		#$00			* RTC ADDRESS ADDRESS BYTE
		STA		I2CDADD
		LDX		#I2CDADD
		CLRA					* BYTES TO SEND (ONE ADDRESS BYTE)
		JSR		I2CTX			* SEND ADDRESS
		LDA		#RTCADDR		* NOW RE-START READ AT $00 (SET ABOVE)
		JSR		I2CREA1			* RE-START READ (SPECIAL RESTART)
		LDX		#I2CBUFF
		LDA		#$08			* READ 8 BYTES
		LDX		#I2CBUFF
		JSR		I2CRX			* READ BYTES INTO I2CBUFF
		JSR		I2CSTOP			* STOP TRANSMISSION
		RTS
*
* I2C RTC WRITE FROM I2CBUFF
*   USES A,X
*
RTCSET	LDA		#RTCADDR
		JSR		I2CWRIT			* START WRITE
		LDA		#$00			* RTC ADDRESS ADDRESS BYTE
		STA		I2CDADD
		LDX		#I2CDADD
		CLRA					* BYTES TO SEND (ONE ADDRESS BYTE)
		JSR		I2CTX			* SEND ADDRESS
		LDX		#I2CBUFF
		LDA		#$08			* WRITE 8 BYTES
		JSR		I2CTX
		JSR		I2CSTOP
		RTS
*
* I2C SERIAL EEPROM GET FIRST 16 BYTES INTO I2CBUFF 
*   USES A,X
*
SEEGET	LDA		#SEEADDR		* GET DEFAULT sEEPROM CHIP SELECT
		JSR		I2CWRIT			* START WRITE 
		LDA		#$00			* sEEPROM ADDRESS HIGH BYTE
		STA		I2CDADD
		LDA		#$00			* sEEPROM ADDRESS LOW BYTE
		STA		I2CDADD+1		
		LDX		#I2CDADD		* SERIAL EEPROM MEMORY ADDRESS, $0000
		LDA		#$01			* BYTES TO SEND (TWO ADDRESS BYTES)
		JSR		I2CTX			* SEND ADDRESS
		LDA		#SEEADDR
		JSR		I2CREAD			* START READ
		LDA		#$0F			* READ 16 BYTES
		LDX		#I2CBUFF
		JSR		I2CRX			* READ BYTES
		JSR		I2CSTOP			* STOP TRANSMISSION
		RTS
*
* I2C SERIAL EEPROM WRITE FIRST 16 BYTES FROM I2CBUFF TO EEPROM 
*   USES A,X
*
SEEPUT	LDA		#SEEADDR		* GET DEFAULT sEEPROM CHIP SELECT
		JSR		I2CWRIT			* START WRITE 
		LDA		#$00			* sEEPROM ADDRESS HIGH BYTE
		STA		I2CDADD
		LDA		#$00			* sEEPROM ADDRESS LOW BYTE
		STA		I2CDADD+1		
		LDX		#I2CDADD		* SERIAL EEPROM MEMORY ADDRESS, $0000
		LDA		#$01			* BYTES TO SEND (TWO ADDRESS BYTES)
		JSR		I2CTX			* SEND ADDRESS	
		LDA		#$0F			* WRITE 16 BYTES
		LDX		#I2CBUFF
		JSR		I2CTX			* WRITE BYTES
		JSR		I2CSTOP			* STOP TRANSMISSION
		RTS
*
* I2C LCD WRITE INITIALIZE
*   USES A,X,Y
*		
* PCF8574 TO LCD MAPPING:	P0	-	RS	REGISTER SELECT 0= INSTRUCTION CMD 1=DATA
*							P1	-	RW	READ/wRITE
*							P2	-	E	CLOCK
*							P3	-	BL	BACKLIGHT	
*							P4	-	D4	TALKS IN 4 BIT MODE TO HD44780
*							P5	-	D5
*							P6	-	D6
*							P7	-	D7
LCDINIT	LDA		#LCDADDR		* START WRITE WITH LCD ADDRESS
		JSR		I2CWRIT
		LDA		#%00000000		* START WITH BL=0, RS=0, RW=0, E=0, KNOWN STATE, BACKLIGHT OFF
		STA		I2CBUFF
		LDX		#I2CBUFF
		CLRA					* BYTES TO SEND (ONE BYTE)
		JSR		I2CTX			* SEND NIBBLE
		LDA		#%00111000		* SEND FUNCSET ($X3) BACKLIGHT ON
		JSR		LCDWIR
		LDY		#$0120			* DELAY > 4.1ms
		JSR 	DELAY
		LDA		#%00111000		* SEND FUNCSET ($X3) SECOND TIME
		JSR		LCDWIR
		LDA		#%00111000		* SEND FUNCSET ($X3) THIRD TIME
		JSR		LCDWIR		
		LDA		#%00101000		* SEND FUNCSET ($X2) SET INTERFACE FOR 4 BIT
		JSR		LCDWIR		
		LDA		#%00101000		* SEND FUNCSET ($28) SET 2 LINE, 5X7 CHAR 
		JSR		LCDWBYC
		LDA		#%00001000		* SEND DISPLAY OFF ($08)
		JSR		LCDWBYC		
		LDA		#%00000001		* SEND CLEAR DISPLAY  ($01)
		JSR		LCDWBYC			
		LDY		#$0120			* DELAY > 4.1ms, WAIT INSTEAD OF READ BUSY
		JSR 	DELAY
		LDA		#%00000110		* SEND ENTRY MODE SET  ($06)
		JSR		LCDWBYC	
		LDA		#%00001110		* SEND DISPLAY ON, CURSOR ON ($0E)
		JSR		LCDWBYC		
		JSR		I2CSTOP			* STOP TRANSMISSION		
		RTS
*
* FORCE WRITE LCD INSTRUCTION TO IR REGISTER (SPECIFICALLY FOR INIT)
*
* PACKED BYTE IN A (D7 D6 D5 D4 BL E RW RS)
*   USES A,X
* 
LCDWIR	ORA		#%00000100		* FLIP CLOCK HI, E=1
		STA		I2CBUFF
		LDX		#I2CBUFF
		CLRA					* BYTES TO SEND (ONE BYTE)
		JSR		I2CTX			* SEND NIBBLE		
		LDA		I2CBUFF			* GET IT BACK IN ACCB
		ANDA	#%11111011		* FLIP CLOCK LO, E=0
		STA		I2CBUFF
		LDX		#I2CBUFF
		CLRA					* BYTES TO SEND (ONE BYTE)
		JSR		I2CTX			* SEND NIBBLE
		RTS						* RETURN WITH CLOCK LO
*
* WRITE LCD COMMAND 1 BYTE AS TWO NIBBLES, UPPER HALF FIRST
*
* BYTE TO SEND IN A (D7 D6 D5 D4 D3 D2 D1 D0), DOES NOT CHECK BUSY, BACKLIGHT ON
*   USES A,X,Y
* 
LCDWBYC	LDY		#$000F			* DELAY > 100uS, WAIT INSTEAD OF READ BUSY
		JSR 	DELAY
		PSHS	A				* TEMP SAVE THE BYTE TO SEND
		ANDA	#%11110000		* CLEAR RS RW E BL
		ORA		#%00001100		* FLIP CLOCK HI, E=1 BACKLIGHT ON
		STA		I2CBUFF
		LDX		#I2CBUFF
		CLRA					* BYTES TO SEND (ONE BYTE)
		JSR		I2CTX			* SEND HI NIBBLE, CLOCK HI		
		LDA		I2CBUFF			* GET IT BACK IN ACCB
		ANDA	#%11111011		* FLIP CLOCK LO, E=0
		STA		I2CBUFF
		LDX		#I2CBUFF
		CLRA					* BYTES TO SEND (ONE BYTE)
		JSR		I2CTX			* SEND HI NIBBLE, CLOCK LO
		PULS	A 				* GET BYTE BACK IN ACCB
		LSLA					* SHIFT LO NIBBLE TO HI NIBBLE
		LSLA
		LSLA
		LSLA
		ANDA	#%11110000		* CLEAR RS RW E BL
		ORA		#%00001100		* FLIP CLOCK HI, E=1 BACKLIGHT ON
		STA	I2CBUFF
		LDX		#I2CBUFF
		CLRA					* BYTES TO SEND (ONE BYTE)
		JSR		I2CTX			* SEND LO NIBBLE, CLOCK HI		
		LDB		I2CBUFF			* GET IT BACK IN ACCB
		ANDA	#%11111011		* FLIP CLOCK LO, E=0
		STA		I2CBUFF
		LDX		#I2CBUFF
		CLRA					* BYTES TO SEND (ONE BYTE)
		JSR		I2CTX			* SEND LO NIBBLE, CLOCK LO		
		RTS						* RETURN WITH CLOCK LO
*
* WRITE LCD DATA 1 BYTE AS TWO NIBBLES, UPPER HALF FIRST, WAIT 100uS
*
* BYTE TO SEND IN B (D7 D6 D5 D4 D3 D2 D1 D0), DOES NOT CHECK BUSY, BACKLIGHT ON
* USES A, Y.  PRESERVES STATE OF X
* 
LCDWBYD	PSHS	X 				* PRESERVE X
		LDY		#$000F			* DELAY > 100uS, WAIT INSTEAD OF READ BUSY
		JSR 	DELAY
		PSHS	A				* TEMP SAVE THE BYTE TO SEND
		ANDA	#%11110000		* CLEAR RS RW E BL
		ORA		#%00001101		* FLIP CLOCK HI, E=1 RS=1 BACKLIGHT ON
		STA		I2CBUFF
		LDX		#I2CBUFF
		CLRA					* BYTES TO SEND (ONE BYTE)
		JSR		I2CTX			* SEND HI NIBBLE, CLOCK HI		
		LDA		I2CBUFF			* GET IT BACK IN ACCB
		ANDA	#%11111011		* FLIP CLOCK LO, E=0
		STA		I2CBUFF
		LDX		#I2CBUFF
		CLRA					* BYTES TO SEND (ONE BYTE)
		JSR		I2CTX			* SEND HI NIBBLE, CLOCK LO
		PULS	A 				* GET BYTE BACK IN ACCB
		LSLA					* SHIFT LO NIBBLE TO HI NIBBLE
		LSLA
		LSLA
		LSLA
		ANDA	#%11110000		* CLEAR RS RW E BL
		ORA		#%00001101		* FLIP CLOCK HI, E=1 RS=1 BACKLIGHT ON
		STA		I2CBUFF
		LDX		#I2CBUFF
		CLRA					* BYTES TO SEND (ONE BYTE)
		JSR		I2CTX			* SEND LO NIBBLE, CLOCK HI		
		LDA		I2CBUFF			* GET IT BACK IN ACCB
		ANDA	#%11111011		* FLIP CLOCK LO, E=0
		STA		I2CBUFF
		LDX		#I2CBUFF
		CLRA					* BYTES TO SEND (ONE BYTE)
		JSR		I2CTX			* SEND LO NIBBLE, CLOCK 
		PULS	X 				* PULL SAVED X
		RTS						* RETURN WITH CLOCK LO
*
* SET DISPLAY DATA AND CURSOR TO (X,Y) ON 20X4 DISPLAY (0,0) IS UPPER LEFT
*
* A= X (0 TO 19 COLUMNS) B= Y (0 TO 3 LINES).  VALUES IN HEX!
*
LCDDXY	CMPB	#$03			* ADD OFFSET IF LINE 4
		BNE		LCDDXY1
		LDB		#$D4			* SET DD RAM ADDRESS TO $54
LCDDXY1	CMPB	#$02			* ADD OFFSET IF LINE 3
		BNE		LCDDXY2
		LDB		#$94			* SET DD RAM ADDRESS TO $14
LCDDXY2	CMPB	#$01			* ADD OFFSET IF LINE 2
		BNE		LCDDXY3
		LDB		#$C0			* SET DD RAM ADDRESS TO $40
LCDDXY3	CMPB	#$00			* ADD OFFSET IF LINE 1
		BNE		LCDDXY4			* 
		LDB		#$80			* SET DD RAM ADDRESS TO $00	
LCDDXY4	PSHS	A 				* ADD A TO B, RESULT IN B
		ADDB	,S+
		PSHS	B 				* SAVE THE LOCATION
		LDA		#LCDADDR		* START WRITE WITH LCD ADDRESS
		JSR		I2CWRIT	
		PULS	A 				* GET THE LOCATION OF DD RAM BACK TO A
		JSR		LCDWBYC			* SEND COMMAND BYTE
		JSR		I2CSTOP			* STOP TRANSMISSION	
		RTS
*
* SET DISPLAY DATA RAM TO $00 (FIRST LINE, FIRST CHAR ON 20X4 DISPLAY)
*  USES A
*
LCDDDL1	LDA		#LCDADDR		* START WRITE WITH LCD ADDRESS
		JSR		I2CWRIT	
		LDA		#$80			* SET DD RAM ADDRESS TO $00
		JSR		LCDWBYC			* SEND COMMAND BYTE
		JSR		I2CSTOP			* STOP TRANSMISSION	
		RTS
*
* SET DISPLAY DATA RAM TO $40 (SECOND LINE, FIRST CHAR ON 20X4 DISPLAY)
*  USES A
*
LCDDDL2	LDA		#LCDADDR		* START WRITE WITH LCD ADDRESS
		JSR		I2CWRIT	
		LDA		#$C0			* SET DD RAM ADDRESS TO $40
		JSR		LCDWBYC			* SEND COMMAND BYTE
		JSR		I2CSTOP			* STOP TRANSMISSION	
		RTS
*
* SET DISPLAY DATA RAM TO $14 (THIRD LINE, FIRST CHAR ON 20X4 DISPLAY)
*  USES A
*
LCDDDL3	LDA		#LCDADDR		* START WRITE WITH LCD ADDRESS
		JSR		I2CWRIT	
		LDA		#$94			* SET DD RAM ADDRESS TO $14
		JSR		LCDWBYC			* SEND COMMAND BYTE
		JSR		I2CSTOP			* STOP TRANSMISSION
		RTS
*
* SET DISPLAY DATA RAM TO $54 (FOURTH LINE, FIRST CHAR ON 20X4 DISPLAY)
*  USES A
*
LCDDDL4	LDA		#LCDADDR		* START WRITE WITH LCD ADDRESS
		JSR		I2CWRIT	
		LDA		#$D4			* SET DD RAM ADDRESS TO $54
		JSR		LCDWBYC			* SEND COMMAND BYTE
		JSR		I2CSTOP			* STOP TRANSMISSION
		RTS
*
* CLEAR DISPLAY AND RETURN CURSOR TO HOME (0,0)
*  USES A
*
LCDCLS	LDA		#LCDADDR		* START WRITE WITH LCD ADDRESS
		JSR		I2CWRIT	
		LDA		#$01			* CLEAR SCREEN
		JSR		LCDWBYC			* SEND COMMAND BYTE
		JSR		I2CSTOP			* STOP TRANSMISSION
		RTS		
*
* PRINT ASCII STRING TO THE LCD MODULE
*  USES A
*
* X= ADDRESS OF ASCII STRING.  MUST END WITH $04 AND BE LESS THAN 20 CHARACTERS LONG
*
LCDSOUT	LDA		#LCDADDR		* START WRITE WITH LCD ADDRESS
		JSR		I2CWRIT
LCDSOLP	LDA		,X+				* PICK UP A CHARACTER AND INC X 
		CMPA	#$04			* IS IT THE EOF MARKER?
		BEQ		LCDSOUE			* YES SO EXIT
		JSR		LCDWBYD			* SEND CHAR TO LCDSOUT
		BRA		LCDSOLP			* LOOP FOR MORE
LCDSOUE	JSR		I2CSTOP			* STOP TRANSMISSION	
		RTS
*
* TEST WRITE LCD
*   USES X
*
LCDTEST	LDX		#LCDTST			* GET STRING ADDR
		JSR		LCDSOUT			* PRINT IT ON THE LCD
		RTS
LCDTST	FCC		' Hello World!'
		FCB	$04
*
* I2C OLED 128X64 DISPLAY INITIALIZE
*   USES A,X
*
OLEDINIT	LDA     #OLEADDR	* START WRITE WITH OLED ADDRESS
			JSR     I2CWRIT 
			LDA     #$18		* 24 BYTES TO SEND FOR OLED INIT
			LDX		#OLEDINTPD	* POINT TO OLED INIT STRING
			JSR     I2CTX       * SEND COMMAND BYTES
			JSR     I2CSTOP     * STOP TRANSMISSION  
			RTS

OLEDINTPD	FCB		$00			* Co=0
			FCB		$A8,$3F		* SET MUX RATIO 128X64 (PIXEL LINES 64-1 = $3F)
			FCB		$D3,$00		* SET DISPLAY OFFSET (VERTICAL SHIFT BY COM 0 = NONE)
			FCB		$40			* SET DISPLAY RAM START LINE (0)
			FCB		$A1			* SET SEGMENT REMAP (COLUMN0 = SEG0)
			FCB		$C8			* SET COM OUTPUT SCAN DIRECTION (SCAN FROM COM127 TO COM0)
			FCB		$DA,$12		* SET COM PINS HARDWARE CONFIG (ALT COM PIN CONFIG)
			FCB		$81,$7F		* SET CONTRAST CONTROL (DEFAULT)
			FCB		$A4			* ENTIRE DISPLAY ON	(RESUME TO RAM CONTENT DISPLAY)
			FCB		$A6			* SET NORMAL DISPLAY (NORMAL, NOT INVERSE)
			FCB		$D5,$80		* SET OSC FREQUENCY (DIVIDE RATION 1. FREQ = 1000b)
			FCB		$8D,$14		* ENABLE CHARGE PUMP REGULATOR (VCCSTATE 14)
			FCB		$D9,$22		* SET PRECHARGE PERIOD (PERIOD 1,2 DEFAULT)
			FCB		$DB,$30		* SET VCOMH DESELECT LEVEL (SLIGHTLY BELOW DEFAULT)
			FCB		$20,$00		* SER MEMORY ADDRESS MODE (HORIZONTAL ADDRESSING MODE)
			FCB		$AF			* SET DISPLAY ON
*
* OLED 128X64 DISPLAY, SET DISPLAY RAM START LINE TO 0 (UPPER LEFT)
*   USES A
*
OLEDHOM		LDA     #OLEADDR	* START WRITE WITH OLED ADDRESS
			JSR     I2CWRIT 
			LDA		#$00		* SET CONTROL BYTE (Co=0, D/C=0)
			JSR 	I2CTXONE
			LDA		#$21		* SET COLUMN ADDRESS (TRIPLE BYTE CONFIG)
			JSR 	I2CTXONE
			LDA		#$00		* COLUMN ADDRESS START AT 0
			JSR 	I2CTXONE
			LDA		#$7F		* COLUMN ADDRESS END AT 127
			JSR 	I2CTXONE
			LDA		#$22		* SET PAGE ADDRESS (TRIPLE BYTE CONFIG)
			JSR 	I2CTXONE
			LDA		#$00		* PAGE ADDRESS START AT 0
			JSR 	I2CTXONE
			LDA		#$07		* PAGE ADDRESS END AT 7
			JSR 	I2CTXONE
			JSR     I2CSTOP     * STOP TRANSMISSION 
			RTS		
*
* OLED 128X64 DISPLAY, CLEAR SCREEN, HOME CURSOR
*   USES A,X
*
OLEDCLS		JSR		OLEDHOM		* SET DISPLAY RAM START TO ZERO
			LDA     #OLEADDR	* START WRITE WITH OLED ADDRESS
			JSR     I2CWRIT 
			LDA		#$40		* SET CONTROL BYTE (Co=0, D/C=1)
			JSR 	I2CTXONE	
			LDX		#$0400		* 128 COLUMNS X 8 ROWS OF 8 BITS = 1024 OR $0400
OLEDCLSLP	LDA		#$00		* ZERO ALL BITS IN COLUMN
			JSR		I2CTXONE	* CLEAR 1 8BIT COLUMN
			LEAX	-1,X		* DECREMENT X
			BNE		OLEDCLSLP	* CONTINUE CLEARING SCREEN
			JSR     I2CSTOP     * STOP TRANSMISSION 	
			JSR		OLEDHOM		* SET DISPLAY RAM START TO ZERO	FOR HOME
			RTS
	
*		
* LCD DIRECT BUS MAPPED INIT ROUTINE
*   USES A,Y
*
LCDBINT	LDA		#%00110000		* SEND FUNCSET ($3X) 
		STA		LCDBIR
		LDY		#$0120			* DELAY > 4.1ms - REQUIRED FOR FIRST FUNCSET
		JSR 	DELAY			* CANT READ BUSY FLAG UNTIL AFTER 3RD FUNCSET
		LDA		#%00110000		* SEND FUNCSET ($3X) SECOND TIME
		STA		LCDBIR
		LDA		#%00110000		* SEND FUNCSET ($3X) THIRD TIME
		STA		LCDBIR		
		JSR		LCDBCHK			* CHECK IF LCD MODULE IS BUSY 
		LDA		#%00110000		* SEND FUNCSET ($3X) SET INTERFACE FOR 8 BIT
		STA		LCDBIR
		JSR		LCDBCHK			* CHECK IF LCD MODULE IS BUSY		
		LDA		#%00111000		* SEND FUNCSET ($38) SET 2 LINE, 5X7 CHAR 
		STA		LCDBIR
		JSR		LCDBCHK			* CHECK IF LCD MODULE IS BUSY
		LDA		#%00001000		* SEND DISPLAY OFF ($08)
		STA		LCDBIR
		JSR		LCDBCHK			* CHECK IF LCD MODULE IS BUSY		
		LDA		#%00000001		* SEND CLEAR DISPLAY  ($01)
		STA		LCDBIR			
		JSR		LCDBCHK			* CHECK IF LCD MODULE IS BUSY
		LDA		#%00000110		* SEND ENTRY MODE SET  ($06)
		STA		LCDBIR
		JSR		LCDBCHK			* CHECK IF LCD MODULE IS BUSY		
		LDA		#%00001110		* SEND DISPLAY ON, CURSOR ON ($0E)
		STA		LCDBIR		
		RTS
*
* LCD DIRECT BUS MAPPED BUSY CHECK
*   PRESERVES A
*
LCDBCHK		PSHS	A				* SAVE A
LCDBCHK1	LDA		LCDBIR			* READ LCD INST REGISTER
			ANDA	#%10000000		* MASK TO BUSY FLAG
			BNE		LCDBCHK1		* BUSY SO TRY AGAIN
			PULS	A				* RESTORE A
			RTS						* EXIT AT NOT BUSY
*
* SET DISPLAY DATA AND CURSOR TO (X,Y) ON 20X4 DISPLAY (0,0) IS UPPER LEFT DIRECT MAPPED LCD
*   USES A,B
*
* A= X (0 TO 19 COLUMNS) B= Y (0 TO 3 LINES).  VALUES IN HEX!
*
LCDBDXY		CMPB	#$03			* ADD OFFSET IF LINE 4
			BNE		LCDBDXY1
			LDB		#$D4			* SET DD RAM ADDRESS TO $54
LCDBDXY1	CMPB	#$02			* ADD OFFSET IF LINE 3
			BNE		LCDBDXY2
			LDB		#$94			* SET DD RAM ADDRESS TO $14
LCDBDXY2	CMPB	#$01			* ADD OFFSET IF LINE 2
			BNE		LCDBDXY3
			LDB		#$C0			* SET DD RAM ADDRESS TO $40
LCDBDXY3	CMPB	#$00			* ADD OFFSET IF LINE 1
			BNE		LCDBDXY4			* 
			LDB		#$80			* SET DD RAM ADDRESS TO $00	
LCDBDXY4	PSHS	A 				* ADD A TO B
			ADDB	,S+
			JSR		LCDBCHK			* CHECK IF LCD MODULE IS BUSY	
			STB		LCDBIR
			RTS
*
* SET DISPLAY DATA RAM TO $00 (FIRST LINE, FIRST CHAR ON 20X4 DISPLAY)
*   USES A
*
LCDBDDL1	LDA		#$80			* SET DD RAM ADDRESS TO $00
			JSR		LCDBCHK			* CHECK IF LCD MODULE IS BUSY
			STA		LCDBIR
			RTS
*
* SET DISPLAY DATA RAM TO $40 (SECOND LINE, FIRST CHAR ON 20X4 DISPLAY)
*   USES A
*
LCDBDDL2	LDA		#$C0			* SET DD RAM ADDRESS TO $40
			JSR		LCDBCHK			* CHECK IF LCD MODULE IS BUSY
			STA		LCDBIR
			RTS
*
* SET DISPLAY DATA RAM TO $14 (THIRD LINE, FIRST CHAR ON 20X4 DISPLAY)
*   USES A
*
LCDBDDL3	LDA		#$94			* SET DD RAM ADDRESS TO $14
			JSR		LCDBCHK			* CHECK IF LCD MODULE IS BUSY
			STA		LCDBIR
			RTS
*
* SET DISPLAY DATA RAM TO $54 (FOURTH LINE, FIRST CHAR ON 20X4 DISPLAY)
*   USES A
*
LCDBDDL4	LDA		#$D4			* SET DD RAM ADDRESS TO $54
			JSR		LCDBCHK			* CHECK IF LCD MODULE IS BUSY
			STA		LCDBIR
			RTS
*
* CLEAR DISPLAY AND RETURN CURSOR TO HOME (0,0) LCD DIRECT BUS MAPPED
*   USES A
*
LCDCLSB	JSR		LCDBCHK			* CHECK IF LCD MODULE IS BUSY
		LDA		#%00000001		* CLEAR SCREEN
		STA		LCDBIR
		RTS	
*
* PRINT ASCII STRING TO THE LCD DIRECT BUS MAPPED MODULE
*   USES A,X
*
* X= ADDRESS OF ASCII STRING.  MUST END WITH $04 AND BE LESS THAN 20 CHARACTERS LONG
*
LCDBSOUT	JSR		LCDBCHK			* CHECK IF LCD MODULE IS BUSY
			LDA		,X+				* PICK UP A CHARACTER AND INC X 
			CMPA	#$04			* IS IT THE EOF MARKER?
			BEQ		LCDBSOUE		* YES SO EXIT
			STA		LCDBDR			* SEND CHAR TO LCD
			BRA		LCDBSOUT		* LOOP FOR MORE
LCDBSOUE	RTS						* STOP TRANSMISSION	
*
* TEST WRITE LCD DIRECT BUS MAPPED
*   USES X
*
LCDBTEST	LDX		#LCDBTST		* GET STRING ADDR
			JSR		LCDBSOUT		* PRINT IT ON THE LCD
			RTS
LCDBTST		FCC		' Hello World! (DB)'
			FCB	$04

*
* DELAY - TIMED DELAY 
*   USES Y
*
* Y= NUMBER OF LOOPS (1 LOOP = 10uS @ 2MHz)
*
DELAY	NOP						* 2 CYC (1 uS AT 2MHz)
		NOP						* 2 CYC
		NOP						* 2 CYC
		NOP						* 2 CYC
		NOP						* 2 CYC
		NOP						* 2 CYC
		NOP						* 2 CYC
		LEAY 	-1,Y			* 4 CYC DEC Y
		BNE		DELAY			* 3 CYC LOOP TILL DONE
		RTS
*					
*          
* GENERAL STRING AREA
*
BEGSTR	FCC	' BEGINNING'
		FCB	$04
ENDSTR	FCC	' ENDING'
		FCB	$04
ADDSTR	FCC	' ADDRESS: '
		FCB	$04
WTHSTR	FCC	' WITH '
		FCB	$04
PRESTR	FCC	' CURRENT LOCATION: '
		FCB	$04
NEWSTR	FCC	' NEW LOCATION: '
		FCB	$04
HOWSTR	FCC	' HOW MANY BYTES? '
		FCB	$04
WHTSTR	FCC	' WHAT BYTES? '
		FCB	$04
BPSTR	FCC	' BREAKPOINT ENCOUNTERED AT $'
		FCB	$04
FIRSTR	FCC	' FIRST LOCATION: '
		FCB	$04
SECSTR	FCC	' SECOND LOCATION: '
		FCB	$04	
BANKSTR	FCC	' BANK 0-3: '
		FCB $04	
CURTIM	FCC	' CURRENT TIME: '
		FCB	$04
NEWTIM	FCC	' SET NEW TIME: '
		FCB	$04
PRCRLF	FCB	$0D,$0A		
		FCB	$04			
ASTR	FCC	'A= $'
		FCB	$04
BSTR	FCC	'B= $'
		FCB	$04
DSTR	FCC	'D= $'
		FCB	$04
XSTR	FCC	'X= $'
		FCB	$04
YSTR	FCC	'Y= $'
		FCB	$04
SSTR	FCC	'S= $'
		FCB	$04
USTR	FCC	'U= $'
		FCB	$04
PCSTR	FCC	'PC=$'
		FCB	$04
CCSTR	FCC	'CC=$'
		FCB	$04
DPSTR	FCC	'DP=$'
		FCB	$04
BPCSTR	FCC	' CONTINUE PROGRAM OR EXIT TO MONITOR <C/E>? '
		FCB	$04
BPRSTR	FCC	' REPLACE BREAKPOINT WITH WHAT OPCODE? '
		FCB	$04
EXISTR	FCC	' EXITING BACK TO PRIMARY TASK...  GOODBYE!'
		FCB	$04
PRNSTR	FCC	' PRINTER OUTPUT ENABLED'
		FCB	$04
PRDSTR	FCC	' PRINTER OUTPUT DISABLED'
		FCB	$04
DWISTR	FCC	' INTEL HEX FORMAT DOWNLOAD.'
		FCB	$0D,$0A
		FCC	' START TRANSFER NOW...'
		FCB	$0D,$0A,$0A,$04
DWSSTR	FCC	' S1 S9 FORMAT DOWNLOAD.'
		FCB	$0D,$0A
		FCC	' START TRANSFER NOW...'
		FCB	$0D,$0A,$0A,$04
DWRSTR	FCB	$0D,$0A,$0A
		FCC	' TRANSFER ERROR!  OPERATION ABORTED.'
		FCB	$0D,$0A,$04
DWESTR	FCB 	$0D,$0A,$0A
		FCC	' TRANSFER COMPLETE.'
		FCB	$0D,$0A,$04
VERSTR	FCC	' ROM VERSIONS FOUND:'
		FCB	$0D,$0A,$0D,$0A
		FCC	'   SMARTBUG ROM  '
		FCB	$04
VERST1	FCC	'   AUX ROM       v'
		FCB	$04
VERST2	FCC	'NONE'
		FCB	$04
HLPSTR	FCB	$0D,$0A
		FCC	' CURRENT COMMANDS:'
		FCB	$0D,$0A
		FCB	$0D,$0A
		FCC	'AI  ASCII INPUT'
		FCB	$0D,$0A
		FCC	'AO  ASCII OUTPUT'
		FCB	$0D,$0A
		FCC	'AU  AUTO MEMORY INPUT'
		FCB	$0D,$0A
		FCC	'BR  BAUD RATE'
		FCB	$0D,$0A
		FCC 'CL  DISPLAY/SET CLOCK'
		FCB $0D,$0A
		FCC 'CP  COMPARE MEMORY BLOCKS'
		FCB $0D,$0A
		FCC	'DS  DOWNLOAD S1 S9 FILES'
		FCB	$0D,$0A
		FCC	'DI  DOWNLOAD INTEL HEX FILES'
		FCB	$0D,$0A
		FCC 'ER  READ FROM EEPROM'
		FCB	$0D,$0A
		FCC 'EW  WRITE TO EEPROM'
		FCB	$0D,$0A
		FCC	'EX  EXAMINE MEMORY'
		FCB	$0D,$0A
		FCC	'FI  FIND BYTES'
		FCB	$0D,$0A
		FCC	'FL  FILL MEMORY'
		FCB	$0D,$0A
		FCC	'GO  GOTO PROGRAM'
		FCB	$0D,$0A
		FCC	'HE  HEX DUMP OF MEMORY'
		FCB	$0D,$0A
		FCC	'MO  MOVE A BLOCK OF MEMORY'
		FCB	$0D,$0A
		FCC	'PR  PRINTER ENABLE/DISABLE'	
		FCB	$0D,$0A
		FCC	'UR  USER COMMAND'
		FCB	$0D,$0A
		FCC	'VR  ROM VERSION NUMBERS'
		FCB	$0D,$0A
		FCC	'XX  EXIT BACK TO PRIMARY TASK'
		FCB	$0D,$0A
		FCC	'??  HELP SCREEN'
		FCB	$04
BUDSTR	FCC	' 0=  EXT  4=  135  8= 1200  C= 4800'
		FCB	$0D,$0A
		FCC	' 1=   50  5=  150  9= 1800  D= 7200'
		FCB	$0D,$0A
		FCC	' 2=   75  6=  300  A= 2400  E= 9600'
		FCB	$0D,$0A
		FCC	' 3=  110  7=  600  B= 3600  F=19200'
		FCB	$0D,$0A,$0D,$0A,$0D,$0A
		FCC	'ENTER NUMBER FOR NEW BAUD RATE: '
		FCB	$04
XENSTR	FCC	'XON/XOFF HANDSHAKING ENABLED'
		FCB	$04
XDSSTR	FCC	'HARDWARE HANDSHAKING DISABLED'
		FCB	$04
ERRSTR	FCC	' Eh?'
		FCB	$04
*
* INTERRUPT & RESET VECTORS
*
		ORG	$FFD7
RESERD	RTI						* NOT USED
SWI3V	JMP	[SW3VEC]
SWI2V	JMP	[SW2VEC]
FIRQV	JMP	[FIRVEC]
IRQV	JMP	[IRQVEC]
SWIV	JMP	[SWIVEC]
NMIV	JMP	[NMIVEC]
*
		FDB	RESERD
		FDB	SWI3V
		FDB	SWI2V
		FDB	FIRQV
		FDB	IRQV
		FDB	SWIV
		FDB	NMIV
		FDB	COLDST
*
*
*
		END
	


